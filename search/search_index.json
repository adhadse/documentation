{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pelias","text":"<p>A modular, open-source geocoder built on top of Elasticsearch for fast and accurate global search.</p> <p>This is a DEMO website, not affiliated by Pelias by any means and is only meant for development purpose</p> <p> </p> A modular, open-source search engine for our world. <p>Pelias is a geocoder powered completely by open data, available freely to everyone.</p> <p> </p> <p> Local Installation \u00b7         Cloud Webservice \u00b7     Documentation \u00b7     Community Chat </p> <p>Pelias is a search engine for places worldwide, powered by open data. It turns addresses and place names into geographic coordinates, and turns geographic coordinates into places and addresses. With Pelias, you\u2019re able to turn your users\u2019 place searches into actionable geodata and transform your geodata into real places.</p> <p>We think open data, open source, and open strategy win over proprietary solutions at any part of the stack and we want to ensure the services we offer are in line with that vision. We believe that an open geocoder improves over the long-term only if the community can incorporate truly representative local knowledge.</p>"},{"location":"#whats-a-geocoder-do-anyway","title":"What's a geocoder do anyway?","text":"<p>Geocoding is the process of taking input text, such as an address or the name of a place, and returning a latitude/longitude location on the Earth's surface for that place.</p> <p></p>"},{"location":"#and-a-reverse-geocoder-whats-that","title":"... and a reverse geocoder, what's that?","text":"<p>Reverse geocoding is the opposite: returning a list of places near a given latitude/longitude point.</p> <p></p>"},{"location":"#what-are-the-most-interesting-features-of-pelias","title":"What are the most interesting features of Pelias?","text":"<ul> <li>Completely open-source and MIT licensed</li> <li>A powerful data import architecture: Pelias supports many open-data projects out of the box but also works great with private data</li> <li>Support for searching and displaying results in many languages</li> <li>Fast and accurate autocomplete for user-facing geocoding</li> <li>Support for many result types: addresses, venues, cities, countries, and more</li> <li>Modular design, so you don't need to be an expert in everything to make changes</li> <li>Easy installation with minimal external dependencies</li> </ul>"},{"location":"#what-are-the-main-goals-of-the-pelias-project","title":"What are the main goals of the Pelias project?","text":"<ul> <li>Provide accurate search results</li> <li>Work equally well for a small city and the entire planet</li> <li>Be highly configurable, so different use cases can be handled easily and efficiently</li> <li>Provide a friendly, welcoming, helpful community that takes input from people all over the world</li> </ul>"},{"location":"#where-did-pelias-come-from","title":"Where did Pelias come from?","text":"<p>Pelias was created in 2014 as an early project at Mapzen. After Mapzen's shutdown in 2017, Pelias is now part of the Linux Foundation.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>Magic! (Just kidding) Like any geocoder, Pelias combines full text search techniques with knowledge of geography to quickly search over many millions of records, each representing some sort of location on Earth.</p> <p>The Pelias architecture has three main components and several smaller pieces.</p> <p></p>"},{"location":"#data-importers","title":"Data importers","text":"<p>The importers filter, normalize, and ingest geographic datasets into the Pelias database. Currently there are six officially supported importers:</p> <ul> <li>OpenStreetMap: supports importing nodes and ways from OpenStreetMap</li> <li>OpenAddresses: supports importing the hundreds of millions of global addresses collected from various authoritative government sources by OpenAddresses</li> <li>Who's on First: supports importing admin areas and venues from Who's on First</li> <li>Geonames: supports importing admin records and venues from Geonames</li> <li>Polylines: supports any data in the Google Polyline format. It's mainly used to import roads from OpenStreetMap</li> <li>CSV: supports importing any data in CSV format, which is great for custom data or proprietary data</li> </ul> <p>We are always discussing supporting additional datasets. Pelias users can also write their own importers, for example to import proprietary data into your own instance of Pelias.</p>"},{"location":"#database","title":"Database","text":"<p>The underlying datastore that does most of the query heavy-lifting and powers our search results. We use Elasticsearch. Currently versions 6 and 7 are supported.</p> <p>We've built a tool called pelias-schema that sets up Elasticsearch indices properly for Pelias.</p>"},{"location":"#frontend-services","title":"Frontend services","text":"<p>This is where the actual geocoding process happens, and includes the components that users interact with when performing geocoding queries. The services are:</p> <ul> <li>API: The API service defines the Pelias API, and talks to Elasticsearch or other services as needed to perform queries.</li> <li>Placeholder: A service built specifically to capture the relationship between administrative areas (a catch-all term meaning anything like a city, state, country, etc). Elasticsearch does not handle relational data very well, so we built Placeholder specifically to manage this piece.</li> <li>PIP: For reverse geocoding, it's important to be able to perform point-in-polygon(PIP) calculations quickly. The PIP service is is very good at quickly determining which admin area polygons a given point lies in.</li> <li>Libpostal: Pelias uses the libpostal project for parsing addresses using the power of machine learning. We use a Go service built by the Who's on First team to make this happen quickly and efficiently.</li> <li>Interpolation: This service knows all about addresses and streets. With that knowledge, it is able to supplement the known addresses that are stored directly in Elasticsearch and return fairly accurate estimated address results for many more queries than would otherwise be possible.</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>These are software projects that are not used directly but are used by other components of Pelias.</p> <p>There are lots of these, but here are some important ones:</p> <ul> <li>model: provide a single library for creating documents that fit the Pelias Elasticsearch schema. This is a core component of our flexible importer architecture</li> <li>wof-admin-lookup: A library for performing administrative lookup using point-in-polygon math. Previously included in each of the importers but now only used by the PIP service.</li> <li>query: This is where most of our actual Elasticsearch query generation happens.</li> <li>config: Pelias is very configurable, and all of it is driven from a single JSON file which we call <code>pelias.json</code>. This package provides a library for reading, validating, and working with this configuration. It is used by almost every other Pelias component</li> <li>dbclient: A Node.js stream library for quickly and efficiently importing records into Elasticsearch</li> </ul>"},{"location":"#helpful-tools","title":"Helpful tools","text":"<p>Finally, while not part of Pelias proper, we have built several useful tools for working with and testing Pelias</p> <p>Notable examples include:</p> <ul> <li>acceptance-tests: A Node.js command line tool for testing a full planet build of Pelias and ensuring everything works. Familiarity with this tool is very important for ensuring Pelias is working. It supports all Pelias features and has special facilities for testing autocomplete queries.</li> <li>compare: A web-based tool for comparing different instances of Pelias (for example a production and staging environment). We have a reference instance at pelias.github.io/compare/</li> <li>dashboard: Another web-based tool for providing statistics about the contents of a Pelias Elasticsearch index such as import speed, number of total records, and a breakdown of records of various types.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>The main documentation lives in the pelias/documentation repository.</p> <p>Additionally, the README file in each of the component repositories listed above provides more detail on that piece.</p> Here's an example API response for a reverse geocoding query <pre><code>$ curl -s \"search.mapzen.com/v1/reverse?size=1&amp;point.lat=40.74358294846026&amp;point.lon=-73.99047374725342&amp;api_key={YOUR_API_KEY}\" | json\n{\n\"geocoding\": {\n\"attribution\": \"https://search.mapzen.com/v1/attribution\",\n\"engine\": {\n\"author\": \"Mapzen\",\n\"name\": \"Pelias\",\n\"version\": \"1.0\"\n},\n\"query\": {\n\"boundary.circle.lat\": 40.74358294846026,\n\"boundary.circle.lon\": -73.99047374725342,\n\"boundary.circle.radius\": 500,\n\"point.lat\": 40.74358294846026,\n\"point.lon\": -73.99047374725342,\n\"private\": false,\n\"querySize\": 1,\n\"size\": 1\n},\n\"timestamp\": 1460736907438,\n\"version\": \"0.1\"\n},\n\"type\": \"FeatureCollection\",\n\"features\": [\n{\n\"geometry\": {\n\"coordinates\": [\n-73.99051,\n40.74361\n],\n\"type\": \"Point\"\n},\n\"properties\": {\n\"borough\": \"Manhattan\",\n\"borough_gid\": \"whosonfirst:borough:421205771\",\n\"confidence\": 0.9,\n\"country\": \"United States\",\n\"country_a\": \"USA\",\n\"country_gid\": \"whosonfirst:country:85633793\",\n\"county\": \"New York County\",\n\"county_gid\": \"whosonfirst:county:102081863\",\n\"distance\": 0.004,\n\"gid\": \"geonames:venue:9851011\",\n\"id\": \"9851011\",\n\"label\": \"Arlington, Manhattan, NY, USA\",\n\"layer\": \"venue\",\n\"locality\": \"New York\",\n\"locality_gid\": \"whosonfirst:locality:85977539\",\n\"name\": \"Arlington\",\n\"neighbourhood\": \"Flatiron District\",\n\"neighbourhood_gid\": \"whosonfirst:neighbourhood:85869245\",\n\"region\": \"New York\",\n\"region_a\": \"NY\",\n\"region_gid\": \"whosonfirst:region:85688543\",\n\"source\": \"geonames\"\n},\n\"type\": \"Feature\"\n}\n],\n\"bbox\": [\n-73.99051,\n40.74361,\n-73.99051,\n40.74361\n]\n}\n</code></pre>"},{"location":"#how-can-i-install-my-own-instance-of-pelias","title":"How can I install my own instance of Pelias?","text":"<p>To try out Pelias quickly, use our Docker setup. It uses Docker and docker-compose to allow you to quickly set up a Pelias instance for a small area (by default Portland, Oregon) in under 30 minutes.</p>"},{"location":"#do-you-offer-a-free-geocoding-api","title":"Do you offer a free geocoding API?","text":"<p>You can sign up for a trial API key at Geocode Earth. A commercial service has been operated by the core development team behind Pelias since 2014 (previously at search.mapzen.com). Discounts and free plans are available for free and open-source software projects.</p>"},{"location":"#whats-it-built-with","title":"What's it built with?","text":"<p>Pelias itself (the import pipelines and API) is written in Node.js, which makes it highly accessible for other developers and performant under heavy I/O. It aims to be modular and is distributed across a number of Node packages, each with its own repository under the Pelias GitHub organization.</p> <p>For a select few components that have performance requirements that Node.js cannot meet, we prefer to write things in Go. A good example of this is the pbf2json tool that quickly converts OSM PBF files to JSON for our OSM importer.</p> <p>Elasticsearch is our datastore of choice because of its unparalleled full text search functionality, scalability, and sufficiently robust geospatial support.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We built Pelias as an open source project not just because we believe that users should be able to view and play with the source code of tools they use, but to get the community involved in the project itself.</p> <p>Especially with a geocoder with global coverage, it's just not possible for a small team to do it alone. We need you.</p> <p>Anything that we can do to make contributing easier, we want to know about.  Feel free to reach out to us via Github, Gitter, email, or Twitter.  We'd love to help people get started working on Pelias, especially if you're  new to open source or programming in general.</p> <p>We have a list of Good First Issues for new contributors.</p> <p>Both this meta-repo and the API service repo are worth looking at, as they're where most issues live. We also welcome reporting issues or suggesting improvements to our documentation.</p> <p>The current Pelias team can be found on Github as missinglink and orangejulius.</p> <p>Members emeritus include: * trescube * dianashk * randyme * seejohnrun * fdansv * sevko * hkrishna * riordan * avulfson17 * tigerlily-he</p>"},{"location":"contributing/","title":"Contribute","text":"<p>Pelias can't succeed without contributions from community members like you! Contributions come in many different shapes and sizes. In this file we provide guidance around two of the most common types of contributions: opening issues and opening pull requests.</p>"},{"location":"contributing/#community-values","title":"Community Values","text":"<p>We ask that you are respectful when contributing to Pelias or engaging with our community. As a community, we appreciate the fact that contributors might be approaching the project from a different perspective and background. We hope that beginners as well as advanced users will be able to use and contribute back to Pelias. We want to encourage contributions and feedback from all over the world, which means that English might not be a contributor's native language, and sometimes we may encounter cultural differences. Contructive disagreements can be essential to moving a project forward, but disrespectful language or behavior will not be tolerated. </p> <p>Above all, be patient, be respectful, and be kind!</p>"},{"location":"contributing/#submitting-issues","title":"Submitting Issues","text":"<p>All issues for Pelias are housed in the pelias/pelias repo. Before opening an issue, be sure to search the repository to see if someone else has asked your question before. If not, go ahead and open a new issue.</p>"},{"location":"contributing/#submitting-technical-bugs","title":"Submitting technical bugs","text":"<p>When submitting bug reports, please be sure to give us as much context as possible so that we can reproduce the error you encountered. Be sure to include: - System conditons (OS, browser, etc) - Steps to reproduce - Expected outcome - Actual outcome - Screenshots, if applicable - Code that exposes the bug, if you have it (such as a failing test or a barebones script)</p>"},{"location":"contributing/#submitting-issues-around-search-result-quality","title":"Submitting issues around search result quality","text":"<p>It's important to get feedback about the quality of local search results. When it comes to things like address structure, capitalization, and spelling errors, your local knowledge will make it easier for us to understand the problem. When submitting issues be sure to include: - Where in the world you were searching - Your search query - Your expected result - Your actual result</p>"},{"location":"contributing/#pull-requests-welcome","title":"Pull Requests Welcome!","text":""},{"location":"contributing/#project-standards-overview","title":"Project standards overview","text":"<p>Pelias has several miscellaneous standards:</p> <ul> <li>we use JSHint for linting</li> <li>we use Github Actions for continuous integration</li> <li>we use Winston for logging</li> <li>we love tests, especially when written with tape</li> <li>we use semver for package versioning</li> <li>we loosely use JSDoc for documenting code, as described here</li> </ul> <p><code>jshint</code> and any unit tests in a project will be automatically invoked when you commit to an existing project; make sure they exit successfully!</p>"},{"location":"contributing/#active-contributors","title":"Active contributors","text":"<p>We'll gladly invite active contributors to become members of the Pelias organization. New members will gain direct write permissions, and with great power comes great responsibility. To ensure that any new repositories that you create conform to Pelias standards, we developed pelias-init, a simple project generator that will initialize all of the boilerplate needed to get started on something new.</p>"},{"location":"fun-facts/","title":"Fun Facts","text":"<p>Here are just some of the interesting things we've come across in our geocoding travels. If you find something thought provoking we'd love a pull request!</p>"},{"location":"fun-facts/#stravenue","title":"Stravenue","text":"<p>A stravenue (portmanteau of street and avenue) is a type of road particular to Tucson, Arizona. The United States Postal Service officially supports the abbreviation STRA for stravenues.[1] A stravenue runs \"diagonally between and intersects a Street and an Avenue.\"[2] By convention in Tucson, streets run east-west while avenues run north-south. However, in a few areas of Tucson, primarily around the central part of the city, which is divided by railroad tracks running diagonally from southeast to northwest, builders created small subdivisions of roads and houses that also are laid out on a diagonal basis rather than the normal east-west or north-south. Most of these subdivisions are located near either Benson Highway or Aviation Highway, which also run southeast to northwest.[3] \"The word Stravenue was originally coined by Roy Drachman when he was developing the subdivision called Pueblo Gardens,\" in 1948.[4]</p> <p>Wikipedia</p> <ul> <li>Source</li> </ul>"},{"location":"fun-facts/#leading-0-house-numbers","title":"Leading 0 house numbers","text":"<p>In Portland, there are Zero-Leading Addresses that are different from non-Zero-Leading addresses. Said another way, there could be two separate residences ~1 mile apart, that have almost the exact same address, with the only differentiation being a leading-zero on the number (not really a number in that case). Trimming off leading zeros from address numbers is not a valid practice for addresses in Portland.</p> <p>see: https://en.wikipedia.org/wiki/Portland,_Oregon#Neighborhoods \u201cEast-West addresses in this area are denoted with a leading zero (instead of a minus sign). This means 0246 SW California St. is not the same as 246 SW California St. Many mapping programs are unable to distinguish...\u201d</p> <p>TriMet</p> <ul> <li>Source</li> <li>Source</li> </ul>"},{"location":"fun-facts/#stranger-than-fiction-agloe-new-york","title":"Stranger than fiction: Agloe, New York","text":"<p>Agloe is a fictional hamlet in Colchester, Delaware County, New York, that became an actual landmark after mapmakers made up the community as a \"copyright trap\".</p> <p></p> <p>Wikipedia</p> <ul> <li>Source</li> </ul>"},{"location":"fun-facts/#circleville-squaring-company","title":"Circleville Squaring Company","text":"<p>Dissatisfaction among residents rose over Circleville's layout, however. During 1837 at the request of the town, the Ohio General Assembly authorized the \"Circleville Squaring Company\" to convert the town plan into a squared grid, as was typical of other platted towns. </p> <p></p> <p>Wikipedia</p> <ul> <li>Source</li> </ul>"},{"location":"fun-facts/#joint-custody-of-pheasant-island","title":"Joint Custody of Pheasant Island","text":"<p>What's really unusual about Pheasant Island is that Spain and France don't share the territory at the same time. By the terms of the 1659 treaty, they alternate sovereignty. Every February, French representatives meet their counterparts on Pheasant Island to hand it over to the Spaniards; every August, they get it back. This has happened over seven hundred times. Geography buff Frank Jacobs has likened this to a 350-year timeshare, or \"an extremely slow game of ping-pong.\" To me, it sounds more like a divorce custody arrangement. \"Is this your weekend to be French? France will pick you up after school.\"</p> <p>Conde Nast Traveler</p> <ul> <li>Source</li> </ul>"},{"location":"fun-facts/#ice-cream-lovers-beware","title":"Ice cream lovers beware!","text":"<p>Carmel-by-the-Sea's one-square mile village is as unique in charm as it is in fun facts. No high heels law*, no street addresses, Clint Eastwood was once mayor, and Doris Day helped make Carmel dog heaven on Earth are a few of the most popular ice breakers when meeting locals and visitors in this European-style town. Also, there are no chain restaurants permitted and an ice cream ordinance.</p> <ul> <li>high heels allowed with permit</li> </ul> <p></p> <ul> <li>Source</li> </ul>"},{"location":"release-notes/","title":"Pelias Release Notes","text":"<p>Pelias as a whole operates on a rolling-release process where we generally recommend the latest version of each individual component.</p> <p>In general, it's safe to mix and match newer and older versions of different components, or upgrade one component at a time.</p> <p>We try to avoid it, but when there is a breaking change in one component, we publish a new major version of that component.</p> <p>Each component has its own release notes published on GitHub.</p> <p>For example, you can view the release notes for the Pelias API at https://github.com/pelias/api/releases.</p> <p>Here are some of the major Pelias repositories and their release notes:</p> <ul> <li>API</li> <li>Elasticsearch schema</li> <li>OpenStreetMap importer</li> <li>OpenAddresses importer</li> <li>Who's on First importer</li> <li>CSV importer</li> </ul>"},{"location":"release-notes/#historical-release-notes","title":"Historical release notes","text":""},{"location":"release-notes/#26-october-2017","title":"26 October 2017","text":""},{"location":"release-notes/#bug-fixes","title":"Bug fixes","text":"<ul> <li>The <code>/place</code> endpoint would sometimes return records from a different layer than the one you asked for, but no longer!</li> <li>Asking the <code>/reverse</code> endpoint to return venues from Geonames used to return a error message. However, it should work, and now it does!</li> </ul>"},{"location":"release-notes/#29-september-2017","title":"29 September 2017","text":""},{"location":"release-notes/#new-features","title":"New features","text":"<p>This release marks a major update of our Placeholder service that is in charge of managing administrative area names. All sorts of queries that need to understand the name of a country, city, county, neighbourhood, or any other administrative area are improved! Especially improved should be queries that use non-English languages. The full details of the code changes are in the Placeholder pull request.</p>"},{"location":"release-notes/#bug-fixes_1","title":"Bug fixes","text":"<p>Over the last few days we have fixed several regressions that could cause bad responses from, and sometimes even crash, our API server.</p>"},{"location":"release-notes/#19-september-2017","title":"19 September 2017","text":""},{"location":"release-notes/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Thanks to @rabidllama's excellent PR, we now support queries with postalcode and region/country combinations.</li> </ul>"},{"location":"release-notes/#14-september-2017","title":"14 September 2017","text":""},{"location":"release-notes/#new-features_1","title":"New features","text":"<ul> <li>We've beefed up downloaders for OpenAddresses, OpenStreetMap, and Who's On First to download subsets of data.</li> <li>The alpha3 flag for country codes have been obsolete for quite some time now but we've removed all vestiges of it.</li> </ul>"},{"location":"release-notes/#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>Some OpenAddresses records have lon/lat at 0/0 meaning that, unless you have a ocean-going yacht and pretty sturdy jet ski, you can't get to addresses there (note to self: start \"Pelias for Yachts\").  We've now excluded those from the build.</li> </ul>"},{"location":"release-notes/#22-august-2017","title":"22 August 2017","text":""},{"location":"release-notes/#new-features_2","title":"New features","text":"<ul> <li>We now support the ability to specify the admin hierarchy part of an address query in any language (as long as a name in that language can be found in WOF), for example searching for 30 w 26th st, \u041d\u044c\u044e \u0419\u043e\u0440\u043a, \ubbf8\uad6d works like magic!</li> <li>We've added a warning when unexpected query parameters are encountered! This is a big deal because it helps catch misspellings of query parameter names, such as <code>layer</code> vs <code>layers</code>... we've all been there at least once.</li> </ul>"},{"location":"release-notes/#bug-fixes_4","title":"Bug fixes","text":"<ul> <li>We found an invalid warning when falling back to a coarse-reverse geocoding strategy about <code>boundary.circle.radius</code> not being supported, even though the query didn't specify a value for that parameter. We removed the unwanted warning. If you see that warning going forward, consider it valid and revise your query.</li> <li>We fixed our production configuration to fully enable language headers (they were only partially available previously). Ooops!</li> </ul>"},{"location":"release-notes/#6-july-2017","title":"6 July 2017","text":""},{"location":"release-notes/#milestones","title":"Milestones","text":"<p>Today's release has no new code, but it's a big milestone nonetheless. For the first time, we are indexing over 500 million (that's half a billion) records, all from open data! We're grateful to all the work from contributors of OpenStreetMap, OpenAddresses, Who's on First, and Geonames that have made this possible and are looking forward to reaching the big one billion mark soon!</p>"},{"location":"release-notes/#30-june-2017","title":"30 June 2017","text":""},{"location":"release-notes/#bug-fixes_5","title":"Bug fixes","text":"<p>Our new Placeholder service queries were working great, except they weren't returning confidence scores. Now they have confidence scores just like all our other queries.</p>"},{"location":"release-notes/#27-june-2017","title":"27 June 2017","text":""},{"location":"release-notes/#new-features_3","title":"New features","text":"<ul> <li>After several months of work we have finally released massively improved admin queries! These use our new service, Placeholder. Placeholder knows all about cities, countries, and every other type of administrative area, and knows the relationships between them, so it can be used to return much better results.</li> </ul>"},{"location":"release-notes/#bug-fixes_6","title":"Bug fixes","text":"<ul> <li>We discovered that we were importing every jetway from OpenStreetMap, which isn't really something anyone wants to geocode, so we've improved our whitelists for what's allowed. Results from OSM should be a little cleaner now.</li> <li>Autocomplete now works correctly on very long names.</li> </ul>"},{"location":"release-notes/#30-may-2017","title":"30 May 2017","text":""},{"location":"release-notes/#new-features_4","title":"New features","text":"<ul> <li>Deduper will now prefer results with postalcodes, which comes to us courtesy of our friend @kevincennis.</li> <li>WOF Macrohoods have been added to the list of supported hierarchies.</li> </ul>"},{"location":"release-notes/#21-april-2017","title":"21 April 2017","text":""},{"location":"release-notes/#new-features_5","title":"New features","text":"<ul> <li>Our first big ticket item is technically a new feature, a code level change, and a bug fix all in one! We've created a standalone microservice whose job it is to handle point-in-polygon requests. So with this release, all reverse queries specifying admin layers will be directed to this new service, instead of going to Elasticsearch like it used to. As a user, you won't see any difference in the interface to these types of requests and you don't have to take any action to use the new functionality. However, faster and better results will be apparent!</li> <li>Our second big ticket item (we know, 2 in one release is awesome sauce!) is the long awaited upgrade to <code>libpostal 1.0</code>. This is again a code level change that doesn't have any user interface implications but yield significant improvements in results. We can tell just by the number of old issues we were able to resolve as a result of this upgrade that this is a big moment for the Pelias engine. High-fives all around!</li> <li>You know how we started supporting search queries with only postalcodes in them, like <code>/v1/search?text=90210</code>? Well get excited, because we've added the ability to handle postalcode only queries in <code>structured</code> search as well! So queries like <code>/v1/search/structures?postalcode=90210</code> will now work. More info here.</li> <li>We fixed a few minor bugs related to address interpolation. There were cases where the results had a mix of street centroids and addresses and the correct address was not showing up first. More details here.</li> <li>There was an issue with geonames admin records having incorrect ids in their admin hierarchy properties. They were basically masquerading as Who's on First ids leading to invalid results and general chaos. Well no more. We fixed it.</li> </ul>"},{"location":"release-notes/#13-march-2017","title":"13 March 2017","text":"<ul> <li>We've added postalcodes to the Who's on First import process and enabled the postalcode-only query type, so users can now find postalcodes directly! 90210 anyone?</li> <li>Dependencies, like San Jose, PRI, should now have the proper alpha3 ISO codes of their own in the country abbreviation (<code>country_a</code>) properties, instead of alpha2 of the parent country as it did previously.</li> <li>Washington DC wasn't getting a region abbreviation at all for a while, but that's water under the Arlington Memorial Bridge now!</li> </ul> <p>Warning: We are having some technical difficulties with the polylines data generated from the OSM road network. This data is used to populate our street index and interpolation service. Both features will continue working as before, but data will be stale until a fix is implemented. We will be using the last known good version, which was built on February 27th, 2017. We will definitely keep everyone posted as soon as an updated working version is available. Sorry for any inconvenience this may have caused.</p>"},{"location":"release-notes/#6-february-2017","title":"6 February 2017","text":"<p>We bring you another data update this week, but don't worry, we're busy working on cool new features and improvements. If you're curious what those might be, come read all about them here!</p>"},{"location":"release-notes/#1-february-2017","title":"1 February 2017","text":"<p>This release is just a data refresh since it's hard to keep up with the leaps and bounds that openaddresses is growing by!</p>"},{"location":"release-notes/#27-january-2017","title":"27 January 2017","text":"<p>Thanks to some wild activity in the openaddresses project, this is the first Pelias build with over 400 million documents!</p> <p>We are excited to see open data continue to grow and improve and looking forward to the big half billion milestone. :)</p>"},{"location":"release-notes/#new-features_6","title":"New features","text":"<ul> <li>Big news! \ud83d\udc2f we have soft-launched our new street interpolation service, which includes TIGER data. This allows us to return more address results than before. For more info, see https://github.com/pelias/interpolation</li> </ul>"},{"location":"release-notes/#bug-fixes_7","title":"Bug fixes","text":"<ul> <li>We've fixed a bug where structured queries would always return 'fallback' as the 'match_type'.</li> </ul>"},{"location":"release-notes/#17-january-2017","title":"17 January 2017","text":"<p>For our second release of the year we bring the first new batch of street data for our polylines dataset (derived from OSM) that we introduced late last year. We'll now be updating that data weekly like everything else!</p>"},{"location":"release-notes/#new-features_7","title":"New features","text":"<ul> <li>The <code>/v1/structured</code> endpoint now supports the <code>venue</code> parameter, which allows for searching for venues with a particular name.</li> <li>We've improved result balance when using <code>focus.point</code> in the autocomplete endpoint. In particular, searching for cities far away from the focus point should work much better. More improvements to <code>focus.point</code> are planned for the near future.</li> </ul>"},{"location":"release-notes/#5-january-2017","title":"5 January 2017","text":"<p>Our first release of 2017 is here! Due to some build issues, this is the first update of data since mid-November. We're happy to be back and have improved our build validation along the way.</p>"},{"location":"release-notes/#28-december-2016","title":"28 December 2016","text":""},{"location":"release-notes/#new-features_8","title":"New features","text":"<ul> <li>Searches for <code>St Louis, MO</code> and <code>Saint Louis, MO</code> now return the same thing (the same goes for towns starting with <code>Mount</code>/<code>Mt</code> and <code>Fort</code>/<code>Ft</code>)</li> <li>Structured geocoding no longer fails horribly when the <code>address</code> parameter consists of only a house number</li> </ul>"},{"location":"release-notes/#05-december-2016","title":"05 December 2016","text":"<p>This week includes only code changes, no data updates. Our production build failed do to an error reading whosonfirst data. We'll either kick off a new build for release later this week, or resume data updates with our usual cadence next week.</p>"},{"location":"release-notes/#new-features_9","title":"New features","text":"<ul> <li>We've released what was previously referred to as component geocoding in the new structured geocoding endpoint! It lives at <code>/v1/search/structured</code></li> <li>We fixed a bug where specifying the same parameter twice (eg <code>/v1/search?text=paris&amp;sources=geonames&amp;sources=gn</code>) would cause a 500 error. It now returns a helpful 400 error message that includes which parameter is duplicated, so that the request can be fixed.</li> <li>Other errors that should have been 500 errors were being returned with status code 400. Fixing this will allow us to more quickly catch any 500 errors that happen in the future.</li> </ul>"},{"location":"release-notes/#18-november-2016","title":"18 November 2016","text":"<ul> <li>We've just released beta support for component geocoding so instead of passing in a single input to the <code>/v1/search</code> endpoint, the parts of an address can be sent to <code>/v1/beta/component</code>!  An example of this is <code>address=201+Spear+St&amp;locality=San+Francisco&amp;region=CA</code>.  We haven't officially named this geocoding type yet, so if you have a naming suggestion, please weigh in here!  Our basic design doc for using this new beta feature is here, please check it out.  We're still working out the final implementation (why it's currently deployed to our <code>/v1/beta</code> test bed) so check it out and don't hesitate to raise any issues you might encounter.  Check out the acceptance tests for some more examples.</li> <li>We're enabling support for more response scenarios from libpostal!  This release we're adding support for city+country, so requests for Paris, France and Reykjav\u00edk, Iceland are a lot cleaner.</li> <li>Speaking of Reykjav\u00edk, Iceland, support for inputs containing diacritics has improved.  Now whether the input is Reykjav\u00edk, Iceland or Reykjavik, Iceland, results should be the same.</li> <li>Whether your input contains a 2- or 3-character ISO country code (<code>FRA</code> vs <code>FR</code>), we'll find it!</li> </ul>"},{"location":"release-notes/#24-october-2016","title":"24 October 2016","text":"<ul> <li>The <code>/v1/autocomplete</code> endpoint now supports boundary.rect just like <code>/v1/search</code></li> <li>Labels for administrative areas should be improved in a few cases</li> </ul>"},{"location":"release-notes/#10-october-2016","title":"10 October 2016","text":"<ul> <li>libpostal, the super-sophisticated address parser, has been integrated for more accurate analysis of inputs at <code>/v1/search</code>.</li> <li>Street names containing post-directionals (e.g. - <code>186 Tuskegee St SE Atlanta GA</code> -&gt; <code>186 Tuskegee St SouthEast Atlanta GA</code>) are now treated the same as their pre-directional brethren.</li> <li>10/10, would release again - geocoding fallback rules that favor traditional geocoding behavior instead of search engine behavior</li> </ul>"},{"location":"release-notes/#19-september-2016","title":"19 September 2016","text":"<p>Another data-only release. Stay tuned for next week!</p>"},{"location":"release-notes/#12-september-2016","title":"12 September 2016","text":"<ul> <li>Get excited for the addition of \u2728 STREETS \u2728! That's right, with this release Pelias gets a brand new <code>street</code> layer, which contains OSM street centroids. With this addition, if we can't find the exact address you're looking for we'll return the street record. Stay tuned for an in-depth blog post in the next few days. \ud83d\udc4f</li> </ul>"},{"location":"release-notes/#7-september-2016","title":"7 September 2016","text":"<ul> <li>Crikey! We noticed we weren't handling Australian province abbreviations, so we added support for them in our labels.</li> <li>Geonames ADM3 records now are correctly listed as localadmins, not venues.</li> <li>Our wonderful, now departed intern made sure Germanic street names are consistently handled (previously, some would end in -strasse while others ended in the abbreviation -str).</li> <li>Records with a Who's on First dependency now have that dependency listed in API responses.</li> </ul>"},{"location":"release-notes/#22-august-2016","title":"22 August 2016","text":"<p>No changes in functionality at all, just the freshest data! We did clean up some tests and do other work only visible to developers and those who run their own Pelias instance, but nothing major.</p> <p>Stay tuned for next week's release where we already have some nice changes queued up.</p>"},{"location":"release-notes/#18-august-2016","title":"18 August 2016","text":"<ul> <li>After much feedback we've added the <code>boundary.country</code> parameter for autocomplete! It works just like the one on the search endpoint.</li> <li>To help make Leaflet maps display results better, we now use use the  <code>lbl:bbox</code> property on Who's on First records. This is useful for places like San Francisco where the mathematical bounding box is bigger than people expect.</li> <li>The API was incorrectly warning against using the <code>boundary.circle</code> parameter. Now it doesn't complain!</li> <li>We've added a new <code>/v1/nearby</code> endpoint that is currently in early alpha! There's no documentation, probably some bugs, and any part of the interface is still subject to change.</li> <li>Finally, we're now running Node.js 4 in production, rather than Node.js 0.12. For those running their own Pelias instance, be aware that we'll be dropping support for Node.js 0.12 in September. At first, things may work on Node.js 0.12, but we're very excited to finally start using ES2016, so that won't last too long.</li> </ul>"},{"location":"release-notes/#8-august-2016","title":"8 August 2016","text":"<p>Incremental release resolving the final outstanding tasks in the Elasticsearch 2 upgrade.</p> <p>We have registered a new website http://pelias.io which has information about the milstones we have planned for the current quarter.</p> <ul> <li>Elasticsearch 2+ does not support co-ordinate wrapping as it did prior to the 2 release. Some front-ends allow users to 'wrap' around the globe. Floats outside of the normal -90/+90 -180/+180 geographic coordinate ranges cause Elasticsearch to error. We added a function to the API which unwraps these coordinates; providing better compatibility with these tools.</li> <li>We added <code>borough</code> as a possible layer for Geonames</li> <li>Since the beginning of the project the Elasticsearch <code>_index</code> name has always been hard-coded as 'pelias', the index names configurable PRs allow this behaviour to be adjusted in your individual pelias config files.</li> <li>We removed the focus.viewport API which was undocumented and never used outside of test suites.</li> </ul>"},{"location":"release-notes/#2-august-2016","title":"2 August 2016","text":"<p>Another bigger than usual release, we had some ops related challenges to resolve after the update to Elasticsearch 2, as well as some data issues, but we also have some great improvements in store!</p> <ul> <li>We use more of the population data in Who's on First, which really helps more relevant cities come up in searches.</li> <li>Searching for only records in certain layers in Geonames now works! We keep adding better handling of Geonames data but sometimes our API code doesn't keep up with those changes.</li> <li>Labels now include county names if there's no city (locality) info present. This helps with addresses that are outside the bounds of any city</li> <li>Capitalization across all OpenAddresess records is now more consistent. We've tried to properly capitalize all records that were either in all caps or all lowercase. This is better in general, although there are certainly exceptions, and we welcome bug reports for those cases.</li> <li>Geonames records for New York City boroughs like Manhattan and Brooklyn are now in the <code>borough</code>, rather than <code>locality</code> layer. This makes them consistent with the records from Who's on First, which have been boroughs for some time.</li> <li>Addresses in the Czech Republic now show the street name before the house number, in keeping with local customs</li> <li>When using the <code>/v1/place</code> endpoint, the source name can either be the full name or the abbreviation (like the <code>sources</code> parameter to the search and autocomplete endpoints). We love saving people some typing :)</li> <li>We've made lots of internal changes like reducing the size of our documents, using a cleaner method to construct layer filter queries, removing dependencies on packages we've deprecated, and allowing the Elasticsearch index name to be configured for both the API and schema packages.</li> <li>In related internal changes news, we've also worked to make sure that all our code works with Node.js version 6, which was recently released! Support for Node.js 0.10, which is quite old and near end-of-life, is also starting to be removed.</li> </ul> <p>We also have two known issues in this build: * Some OpenAddresses records for the statewide data in Massachusetts, USA are incorrect. This is because of an issue when changing data sources that will be resolved in the next OpenAddresses build * Geonames <code>localadmin</code> records, like the City of New York will have extra components in the label (in this case, \"Brooklyn, New York\"). The fix for this is merged but was accidentally omitted from this build. Look forward to it next week!</p>"},{"location":"release-notes/#07-july-2016","title":"07 July 2016","text":"<ul> <li>Big news: We've finally upgraded to Elasticsearch 2.3! This brings improved performance and more importantly sets us up for lots of improvements from the new features of Elasticsearch 2. Elasticsearch 1.7 is no longer supported.</li> <li>As part of the Elasticsearch 2 upgrade we've also improved a few edge cases for searching for numeric values, and with single character tokens. You can read more in the Github issue for the upgrade.</li> <li>We've also fixed some lingering issues where a few places in Denmark were listed as being part of Sweden. This was due to the same data bug as mentioned in our recent blog post.</li> <li>The OpenAddresses importer now has better whitespace cleanup, so there won't be any extra spaces in street names.</li> <li>We recently added data to new layers in Geonames, but the API didn't know about it, and prevented you from searching for them. We fixed it.</li> </ul>"},{"location":"release-notes/#13-june-2016","title":"13 June 2016","text":"<ul> <li>Who's on First importer: records now use the label centroid if it's present. The previous behavior was to always use the center of the record's bounding box. In cases like San Francisco, this caused the record to not show up where people expect!</li> <li>Openstreetmap importer: A bug in config parameter handling that caused admin lookup to be disabled when it shouldn't was fixed. Thanks to @dylanFrese for helping us catch this tricky one.</li> </ul>"},{"location":"release-notes/#26-may-2016","title":"26 May 2016","text":"<ul> <li>We did it... we removed an Elasticsearch analyzer that was presumptuously assuming all queries were in English! The <code>k-stemming</code> analysis would do strange things like turn Daly into Dale, so finding \"Daly City\" was a challange. Well, no more! Word of warning, in <code>/search</code> we are now less forgiving when someone uses a plural version of a word where the real name is singular.</li> </ul>"},{"location":"release-notes/#23-may-2016","title":"23 May 2016","text":"<ul> <li>All the extra 0's have been eradicated in addresses coming from OpenAddresses. You should not see any house numbers that reduce to 0 or any leading 0's in house numbers.</li> <li>Added the mysteriously missing <code>source_id</code> property to response features. This property represents the original id at the source, if one existed, like in OSM and WOF. Where it didn't we made one up to help uniquely identify each record.</li> </ul>"},{"location":"release-notes/#09-may-2016","title":"09 May 2016","text":"<ul> <li>Cleaned up some invalid address data from our OpenAddresses import by removing anything with words like <code>NULL</code>, <code>UNDEFINED</code>, and <code>UNAVAILABLE</code>.</li> <li>Improved error reporting in the API so users can decipher what went wrong much easier. More specifically, there are errors that Elasticsearch reports and we propogate up to the API response.</li> </ul>"},{"location":"release-notes/#29-april-2016","title":"29 April 2016","text":"<ul> <li>A big improvements to autocomplete results coming from numerous bug fixes and improvements! More details can be found in the pull requests: pelias/schema#127 and pelias/api#526. Some highlights include:</li> <li>Single digit housenumbers like <code>8 Main St</code> can be found more easily</li> <li>Support for searching for the street name before the house number, as is common in many European countries, is improved.</li> <li>Searches that end in common words no longer return no results. These were being treated as stopwords internally in Elasticsearch. Now queries such as <code>Moscone West</code> will work better</li> <li>Remove OpenAddresses records with 0 housenumbers in US/CA</li> </ul>"},{"location":"release-notes/#18-april-2016","title":"18 April 2016","text":"<ul> <li>Address parsing now works without spaces after commas. This was our bad. Feel free to leave those spaces out as long as you provide commas to delimit admin parts.</li> <li>Further streamlining of labels. You can expect the labels to a have more consistent and minimal feel. If the results are coming from New York, expect boroughs such as Manhattan, Brooklyn, Queens, etc. to be part of the label. You're welcome New Yorkers! :heart:</li> <li>Fixed a bug where specifying <code>layers=macrocounty</code> would fail due to a typo in the API code. You can see how easy it is to mistype <code>macrocounty</code> and not notice that <code>macrocountry</code> is incorrect. #onlyhuman</li> </ul>"},{"location":"release-notes/#08-april-2016","title":"08 April 2016","text":"<p>This release marks the official integration of the Mapzen <code>Who's on First</code> data set into Pelias. This data is replacing <code>Quattroshapes</code> across the entire service. Any forward usage or references to <code>Quattroshapes</code> will be replaced with <code>WhosOnFirst</code>. This substitution allows us to fix long-standing encoding issues in administrative hierarchy place-names. We've also added a bounding box for individual features in the results, not only the all-encompassing bounding box at the top level of the geojson results. Also, the all-encompassing bounding box will extend to include the bounding boxes of all the features in the results, not only their centroids. Another major improvement that many have been waiting for is the addition of more filters for the <code>/autocomplete</code> endpoint. Users can now ask <code>/autocomplete</code> to filter by <code>layers</code> and <code>sources</code>, as documented here. See the detailed list of changes below for more specifics.</p> <ul> <li>Switched from <code>Quattroshapes</code> to <code>WhosOnFirst</code> as the canonical source for administrative hierarchies and corresponding geometries.</li> <li>No longer importing <code>Quattroshapes</code> data since <code>WhosOnFirst</code> contains all those records and more. Going forward, any use of <code>quattroshapes</code> or <code>qs</code> in queries will resolve to <code>whosonfirst</code> or <code>wof</code> automatically.</li> <li>New <code>bbox</code> property has been added to individual results, for which geometry was available in the original source. This does not affect POI and address data.</li> <li>Drastic improvements have been made to the label generation logic.</li> <li><code>id</code> and <code>gid</code> format has changed to make the ids more unique.</li> <li>New id format resolves previously outstanding bugs related to <code>geonames</code> ids being invalid for lookup via the <code>/place</code> endpoint.</li> <li>Additional place-types have been introduced, such as <code>macroregion</code>, <code>macrocounty</code>, and <code>borough</code>.</li> <li><code>gid</code> values have been added for each parent in the admin hierarchies of results.</li> <li><code>/autocomplete</code> now allows filtering by <code>sources</code> and <code>layers</code>.</li> <li>Fixed a bug that allowed <code>/autocomplete</code> to accept the <code>size</code> parameter. The default and only size of <code>/autocomplete</code> results is now <code>10</code>, as originally intended.</li> </ul>"},{"location":"development/code-of-conduct/","title":"Contributor Code of Conduct","text":"<p>This code of conduct outlines our expectations for participants within the Pelias community, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Anyone who violates this code of conduct may be banned from the community.</p> <p>Our open source community strives to:</p> <ul> <li>Be friendly and patient.</li> <li>Be welcoming: We strive to be a community that welcomes and supports people of all backgrounds and identities. This includes, but is not limited to members of any race, ethnicity, culture, national origin, colour, immigration status, social and economic class, educational level, sex, sexual orientation, gender identity and expression, age, size, family status, political belief, religion, and mental and physical ability.</li> <li>Be considerate: Your work will be used by other people, and you in turn will depend on the work of others. Any decision you take will affect users and colleagues, and you should take those consequences into account when making decisions. Remember that we're a world-wide community, so you might not be communicating in someone else's primary language.</li> <li>Be respectful:  Not all of us will agree all the time, but disagreement is no excuse for poor behavior and poor manners. We might all experience some frustration now and then, but we cannot allow that frustration to turn into a personal attack. It\u2019s important to remember that a community where people feel uncomfortable or threatened is not a productive one.</li> <li>Be careful in the words that we choose: we are a community of professionals, and we conduct ourselves professionally. Be kind to others. Do not insult or put down other participants. Harassment and other exclusionary behavior aren't acceptable.</li> <li>Try to understand why we disagree: Disagreements, both social and technical, happen all the time. It is important that we resolve disagreements and differing views constructively. Remember that we\u2019re different. The strength of our community comes from its diversity, people from a wide range of backgrounds. Different people have different perspectives on issues. Being unable to understand why someone holds a viewpoint doesn\u2019t mean that they\u2019re wrong. Don\u2019t forget that it is human to err and blaming each other doesn\u2019t get us anywhere. Instead, focus on helping to resolve issues and learning from mistakes.</li> </ul>"},{"location":"development/code-of-conduct/#definitions","title":"Definitions","text":"<p>Harassment includes, but is not limited to:</p> <ul> <li>Offensive comments related to gender, gender identity and expression, sexual orientation, disability, mental illness, neuro(a)typicality, physical appearance, body size, race, age, regional discrimination, political or religious affiliation</li> <li>Unwelcome comments regarding a person\u2019s lifestyle choices and practices, including those related to food, health, parenting, drugs, and employment</li> <li>Deliberate misgendering. This includes deadnaming or persistently using a pronoun that does not correctly reflect a person's gender identity. You must address people by the name they give you when not addressing them by their username or handle</li> <li>Physical contact and simulated physical contact (eg, textual descriptions like \u201chug\u201d or \u201cbackrub\u201d) without consent or after a request to stop</li> <li>Threats of violence, both physical and psychological</li> <li>Incitement of violence towards any individual, including encouraging a person to commit suicide or to engage in self-harm</li> <li>Deliberate intimidation</li> <li>Stalking or following</li> <li>Harassing photography or recording, including logging online activity for harassment purposes</li> <li>Sustained disruption of discussion</li> <li>Unwelcome sexual attention, including gratuitous or off-topic sexual images or behaviour</li> <li>Pattern of inappropriate social contact, such as requesting/assuming inappropriate levels of intimacy with others</li> <li>Continued one-on-one communication after requests to cease</li> <li>Deliberate \u201couting\u201d of any aspect of a person\u2019s identity without their consent except as necessary to protect others from intentional abuse</li> <li>Publication of non-harassing private communication</li> </ul> <p>Our open source community prioritizes marginalized people\u2019s safety over privileged people\u2019s comfort. We will not act on complaints regarding:</p> <ul> <li>\u2018Reverse\u2019 -isms, including \u2018reverse racism,\u2019 \u2018reverse sexism,\u2019 and \u2018cisphobia\u2019</li> <li>Reasonable communication of boundaries, such as \u201cleave me alone,\u201d \u201cgo away,\u201d or \u201cI\u2019m not discussing this with you\u201d</li> <li>Refusal to explain or debate social justice concepts</li> <li>Communicating in a \u2018tone\u2019 you don\u2019t find congenial</li> <li>Criticizing racist, sexist, cissexist, or otherwise oppressive behavior or assumptions</li> </ul>"},{"location":"development/code-of-conduct/#diversity-statement","title":"Diversity Statement","text":"<p>We encourage everyone to participate and are committed to building a community for all. Although we will fail at times, we seek to treat everyone both as fairly and equally as possible. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong.</p> <p>Although this list cannot be exhaustive, we explicitly honor diversity in age, gender, gender identity or expression, culture, ethnicity, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.</p>"},{"location":"development/code-of-conduct/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior\u2014or have any other concerns\u2014please report it by contacting us via team@pelias.io. All reports will be handled with discretion. In your report please include:</p> <ul> <li>Your contact information.</li> <li>Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link.</li> <li>Any additional information that may be helpful.</li> </ul> <p>After filing a report, a representative will contact you personally, review the incident, follow up with any additional questions, and make a decision as to how to respond. If the person who is harassing you is part of the response team, they will recuse themselves from handling your incident. If the complaint originates from a member of the response team, it will be handled by a different member of the response team. We will respect confidentiality requests for the purpose of protecting victims of abuse.</p>"},{"location":"development/code-of-conduct/#attribution-acknowledgements","title":"Attribution &amp; Acknowledgements","text":"<p>We all stand on the shoulders of giants across many open source communities.  We'd like to thank the communities and projects that established code of conducts and diversity statements as our inspiration:</p> <ul> <li>Django</li> <li>Python</li> <li>Ubuntu</li> <li>Contributor Covenant</li> <li>Geek Feminism</li> <li>Citizen Code of Conduct </li> </ul> <p>This text was adopted from the Open Code of Conduct published by TODO. Source text available here.</p>"},{"location":"development/repository-list/","title":"Pelias repository list","text":"<p>This is a list of all active Pelias repositories. It can be useful for tracking changes we have to make across all our repositories</p>"},{"location":"development/repository-list/#services","title":"services","text":"<ul> <li>[ ] api</li> <li>[ ] pip-service</li> <li>[ ] placeholder</li> <li>[ ] interpolation</li> <li>[ ] libpostal-service</li> <li>[ ] spatial</li> </ul>"},{"location":"development/repository-list/#importers","title":"importers","text":"<ul> <li>[ ] whosonfirst</li> <li>[ ] openaddresses</li> <li>[ ] geonames</li> <li>[ ] polylines</li> <li>[ ] openstreetmap</li> <li>[ ] transit</li> <li>[ ] csv-importer</li> </ul>"},{"location":"development/repository-list/#support-modules","title":"support modules","text":"<ul> <li>[ ] query</li> <li>[ ] pbf2json</li> <li>[ ] parser</li> <li>[ ] blacklist-stream</li> <li>[ ] logger</li> <li>[ ] dbclient</li> <li>[ ] config</li> <li>[ ] schema</li> <li>[ ] sorting</li> <li>[ ] microservice-wrapper</li> <li>[ ] mock-logger</li> <li>[ ] labels</li> <li>[ ] categories</li> <li>[ ] wof-admin-lookup</li> <li>[ ] fuzzy-tester</li> <li>[ ] model</li> <li>[ ] polygon-lookup</li> <li>[ ] analysis</li> <li>[ ] lastline</li> </ul>"},{"location":"development/repository-list/#testing","title":"testing","text":"<ul> <li>[ ] acceptance-tests</li> <li>[ ] loadtest</li> <li>[ ] fuzzy-tests</li> </ul>"},{"location":"development/repository-list/#meta","title":"meta","text":"<ul> <li>[ ] dashboard</li> <li>[ ] compare</li> <li>[ ] pelias</li> <li>[ ] documentation</li> <li>[ ] ci-tools</li> </ul>"},{"location":"development/repository-list/#docker","title":"docker","text":"<ul> <li>[ ] docker</li> <li>[ ] docker-baseimage</li> <li>[ ] docker-libpostal_baseimage</li> </ul>"},{"location":"development/repository-list/#web-modules","title":"web modules","text":"<ul> <li>[ ] leaflet-plugin</li> </ul>"},{"location":"development/repository-list/#deployment","title":"deployment","text":"<ul> <li>[ ] kubernetes</li> <li>[ ] packer-elasticsearch</li> <li>[ ] terraform-elasticsearch</li> <li>[ ] elasticsearch-health-logger</li> </ul>"},{"location":"development/repository-list/#misc","title":"misc","text":"<ul> <li>[ ] mars-importer</li> <li>[ ] slack-search-app</li> <li>[ ] ownership</li> <li>[ ] scripts-geocoding-coverage</li> <li>[ ] geocoder-test-suite</li> <li>[ ] pelias-android-sdk</li> <li>[ ] presentation</li> <li>[ ] scripts-batch-search</li> <li>[ ] pelias-ios-sdk</li> <li>[ ] batch-search-app</li> </ul>"},{"location":"development/roadmap/","title":"Development Roadmap","text":"<p>Pelias has a long list of features and improvements we wish to make. While we track most of them in GitHub issues, this document records high level priorities for the development of the project as a whole.</p> <p>As an open-source project, we don't usually have a timeline or estimate for when items on our roadmap will be completed, but this document does serve as a roughly priority order of major changes we hope to make.</p>"},{"location":"development/roadmap/#fuzzy-matchingtypo-correction-for-autocomplete","title":"Fuzzy matching/typo correction for autocomplete","text":"<p>The Pelias autocomplete endpoint currently supports extremely limited typo correction. However, this support is really a result of implementation details, and not a result of a concerted effort.</p> <p>By adding such a feature in a deliberate way we can greatly increase the usability of the autocomplete endpoint.</p>"},{"location":"development/roadmap/#integrate-the-new-spatial-service-for-improved-geospatial-capabilities","title":"Integrate the new Spatial service for improved geospatial capabilities","text":"<p>Pelias currently has a component called the PIP service for performing point in polygon calculations, but it's architecture and capabilities have become a huge limiting factor for Pelias.</p> <p>Over the past year, we have been working on a more powerful and efficient replacement, the Spatial service.</p> <p>The spatial service will allow advanced functionality such as custom administrative areas, using administrative data from OpenStreetMap, returning polygon data in Pelias responses, or adding postalcodes to more records based on a geometry.</p>"},{"location":"development/roadmap/#expanded-input-language-support","title":"Expanded input language support","text":"<p>Overall, Pelias has a solid foundation of language and internationalization support. The Pelias data schema allows for records to have multiple name values. These might include names in different languages, alternate names, colloquial names, or common abbreviations (for example airport codes).</p> <p>However, not all data importers currently add multiple names, even when they are available in the source data. Furthermore, not all our queries use these alternate names effectively.</p> <p>Pelias currently supports querying for administrative areas in many languages on the <code>/v1/search</code> endpoint.</p> <p>For autocomplete, the queries are not currently able to utilize multiple administrative area names.</p> <p>Additionally, due to limitations in the polylines data format, no streets imported from OSM include alternate names, even if they are available in OSM.</p>"},{"location":"documentation/","title":"Pelias Documentation","text":"<p>Here is where you can find all documentation for the Pelias geocoder.</p>"},{"location":"documentation/#core-features-and-api-documentation","title":"Core Features and API Documentation","text":""},{"location":"documentation/#endpoint-descriptions","title":"Endpoint descriptions","text":"<ul> <li>Forward geocoding (/v1/search) to find a place by searching for an address or name</li> <li>Reverse geocoding (/v1/reverse) to find what is located at a certain coordinate location</li> <li>Autocomplete (/v1/autocomplete) to give real-time result suggestions without having to type the whole location</li> <li>Structured Geocoding (/v1/search/structured) (beta) to find a place with data already separated into housenumber, street, city, etc</li> <li>Place endpoint (/v1/place) for details on a place returned from a previous query</li> </ul> <p>Not sure which Endpoint to use? We have a page for that</p>"},{"location":"documentation/#query-parameters-and-options","title":"Query parameters and options","text":"<ul> <li>Global coverage with prioritized local results</li> <li>Language support for seeing results in different languages</li> </ul>"},{"location":"documentation/#response-properties","title":"Response Properties","text":"<ul> <li>Full list of response properties</li> <li>Confidence scores, match_types and other tools for determining result quality</li> </ul>"},{"location":"documentation/#data-sources","title":"Data Sources","text":"<ul> <li>Pelias data sources</li> </ul>"},{"location":"documentation/#running-your-own-pelias","title":"Running your own Pelias","text":"<ul> <li>Getting started Start here if you're looking to install Pelias</li> <li>Pelias from scratch More in-depth instructions for installing Pelias</li> <li>Full planet build considerations Special information on running a full planet Pelias build</li> <li>Service descriptions A description of all the Pelias services, and when they are used</li> <li>Software Requirements A list of all software requirements for Pelias</li> </ul>"},{"location":"documentation/#pelias-project-development","title":"Pelias project development","text":"<ul> <li>Release notes. See notable changes in Pelias over time</li> <li>Development roadmap. Plans for future improvements to Pelias. Read this to see what's coming and how you can help</li> </ul>"},{"location":"documentation/#misc","title":"Misc","text":"<ul> <li>Glossary of common terms</li> </ul>"},{"location":"documentation/add-search-to-a-map/","title":"Add the Pelias geocoder to a map","text":"<p>Pelias is a modern, geographic search service based entirely on open-source tools and open data. Use this functionality to enhance any app that has a geographic context, such as ones that help in delivering goods, locating hotels or venues, or providing local weather forecasts.</p> <p>Through a process known as geocoding, Pelias allows you to enter an address or the name of a landmark or business, and the service translates the result into geographic coordinates for mapping. Pelias is built on Pelias, an open-source geocoding project.</p>"},{"location":"documentation/add-search-to-a-map/#get-ready-for-the-tutorial","title":"Get ready for the tutorial","text":"<p>In this tutorial, you will learn how to make a map with a search box that allows you to enter addresses and place names and locate them on a map. To complete the tutorial, you should have some familiarity with HTML and JavaScript, although all the source code is provided. You can use any text editor and operating system, but must keep an Internet connection while you are working.</p> <p>You also need a Mapzen API key, which you can get by following the steps in the Mapzen developer overview.</p> <p>To get started making your map, you will need to use a text editor to update the HTML. See some of Mapzen's suggested text editors in the developer guide documentation.</p>"},{"location":"documentation/add-search-to-a-map/#create-an-html-page","title":"Create an HTML page","text":"<p>You are ready to start building your web page and map.</p> <p>Tip: The end of this page has a finished version of the code that you can use to check your work or review if you need to troubleshoot an error.</p> <ol> <li> <p>Start your text editor with a blank document and copy and paste the following HTML. (Note: If the text editor you are using requires you to name and save a document at the time when it is first created, call the file <code>index.html</code>.)</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>These form the basic structure of an HTML document. <code>&lt;!DOCTYPE html&gt;</code> goes at the top of every HTML page and indicates that it is written for HTML5, and the <code>&lt;html&gt;</code> tags tell your browser that the content is HTML. The <code>&lt;head&gt;</code> tag contains the title for the page and other metadata about the page, while the <code>&lt;body&gt;</code> is where you add the code and the rest of the content on your page. There are many web tutorials available to help you experiment with and learn more about HTML documents and the tags in them.</p> </li> <li> <p>In the <code>&lt;head&gt;</code> tag, add a title, such as <code>&lt;title&gt;My Geocoding Map&lt;/title&gt;</code>.</p> </li> <li> <p>On the next line, add a metadata tag so you can properly display diacritics and characters from different languages.</p> <pre><code>&lt;meta charset=\"utf-8\"&gt;\n</code></pre> </li> <li> <p>Name your the document <code>index.html</code> (where the file name is <code>index</code> and the type is <code>.html</code>) and save it.</p> </li> <li> <p>Drag your index.html file onto a web browser tab. It should show your title, <code>My Geocoding Map</code>, but the web page canvas will be blank.</p> <p></p> </li> </ol> <p>Your HTML should look like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My Geocoding Map&lt;/title&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"documentation/add-search-to-a-map/#add-references-to-css-and-javascript-files","title":"Add references to CSS and JavaScript files","text":"<p>A cascading style sheet (CSS) is used to style a webpage, including layout and fonts, and JavaScript adds functionality to the page. In your <code>index.html</code> file, you need to list the CSS and JavaScript files needed to build your page.</p> <p>The Leaflet JavaScript library provides tools for building an interactive map for web and mobile devices. Leaflet is extensible, and developers have built additional tools for Leaflet maps.</p> <p>The Mapzen.js library simplifies the process of using Mapzen's maps within Leaflet. Mapzen.js contains all the Leaflet functionality, as well as additional tools for working with Mapzen maps and search.</p> <ol> <li> <p>In <code>index.html</code>, at the bottom of the <code>&lt;head&gt;</code> section, add references to the Mapzen.js CSS and JavaScript files.</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://mapzen.com/js/mapzen.css\"&gt;\n&lt;script src=\"https://mapzen.com/js/mapzen.min.js\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>Save your edits and refresh the browser. The webpage should still appear empty because you have not added any code to interact with these references.</p> </li> </ol> <p>After adding these, your index.html file should look something like this.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My Geocoding Map&lt;/title&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://mapzen.com/js/mapzen.css\"&gt;\n&lt;script src=\"https://mapzen.com/js/mapzen.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Note that you are linking to a website that is serving the Mapzen.js CSS and JavaScript, but you can also view, download, and contribute to the source code if you want to access the contents of the library.</p>"},{"location":"documentation/add-search-to-a-map/#add-a-map-to-the-page","title":"Add a map to the page","text":"<p>To display a Leaflet map on a page, you need a <code>&lt;div&gt;</code> element, which is a container on the page that groups elements, with an ID value. If you want to know more about initializing a Leaflet map, see the Leaflet getting started documentation.</p> <ol> <li> <p>At the bottom of the <code>&lt;head&gt;</code> section, after the references you added in the earlier steps, add a <code>&lt;style&gt;</code> tag and the following attributes to set the size of the map on your webpage. A Leaflet map will not display unless you include a width.</p> <pre><code>&lt;style&gt;\n#map {\nheight: 100%;\nwidth: 100%;\nposition: absolute;\n}\nhtml,body{margin: 0; padding: 0}\n&lt;/style&gt;\n</code></pre> </li> <li> <p>At the top of the <code>&lt;body&gt;</code> section, add the <code>&lt;div&gt;</code>.</p> <pre><code>&lt;div id='map'&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Directly after the <code>&lt;div&gt;</code>, add this JavaScript code within a <code>&lt;script&gt;</code> tag to set the API key for the map.</p> <pre><code>&lt;script&gt;\nL.Mapzen.apiKey = \"your-mapzen-api-key\";\n&lt;/script&gt;\n</code></pre> </li> <li> <p>Inside the same <code>&lt;script&gt;</code> tag, and after the code you just added for the API key, initialize a map.</p> <pre><code>&lt;script&gt;\nL.Mapzen.apiKey = \"your-mapzen-api-key\";\nvar map = L.Mapzen.map(\"map\", {\ncenter: [47.61033,-122.31801],\nzoom: 16,\n});\n&lt;/script&gt;\n</code></pre> <p><code>L.xxxxx</code> is a convention used with the Leaflet API. The <code>center: [47.61033,-122.31801]</code> parameter sets the center point of the map, in decimal degrees, at the location of a building at Seattle University.</p> <p>The next line sets the <code>zoom</code> level, which is like a map scale or resolution, where a smaller value shows a larger area in less detail, and a larger zoom level value depicts smaller area in great detail.</p> </li> <li> <p>Save your edits and refresh the browser.</p> </li> </ol> <p>Your index.html should look something like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"/&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt;\n&lt;link rel=\"stylesheet\" href=\"https://mapzen.com/js/mapzen.css\"&gt;\n&lt;script src=\"https://mapzen.com/js/mapzen.min.js\"&gt;&lt;/script&gt;\n&lt;style&gt;\n#map {\nheight: 100%;\nwidth: 100%;\nposition: absolute;\n}\nhtml,body{margin: 0; padding: 0}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id='map'&gt;&lt;/div&gt;\n&lt;script&gt;\nL.Mapzen.apiKey = \"your-mapzen-api-key\";\nvar map = L.Mapzen.map(\"map\", {\ncenter: [47.61033,-122.31801],\nzoom: 16,\n});\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>At this point, you have a map! You should see a map, zoom controls, and attribution in the bottom corner.</p> <p>To recap how you created this, you added references to the Mapzen JS and CSS files, a map <code>&lt;div&gt;</code> with a declared width, and assigned the <code>map</code> value to <code>L.Mapzen.map</code>.</p> <p></p>"},{"location":"documentation/add-search-to-a-map/#add-the-search-box","title":"Add the Search box","text":"<p>So far, you have referenced the necessary files, initialized Leaflet with a map container on the page, and added data to the map. Now, you are ready to add the Search box.</p> <ol> <li> <p>Inside the same <code>&lt;script&gt;</code> tag, and after the code you just added for the map, initialize a search box and add it to the map with the following code.</p> <pre><code>var geocoder = L.Mapzen.geocoder();\ngeocoder.addTo(map);\n</code></pre> </li> <li> <p>Save your edits and refresh the browser. You should see search button in the left corner. If you want to expand the button to a box, you can change this behavior in the geocoder options.</p> <p></p> </li> </ol> <p>Your <code>&lt;body&gt;</code> section should look like this:</p> <pre><code>[...]\n&lt;script&gt;\nL.Mapzen.apiKey = \"your-mapzen-api-key\";\nvar map = L.Mapzen.map(\"map\", {\ncenter: [47.61033,-122.31801],\nzoom: 16,\n});\nvar geocoder = L.Mapzen.geocoder();\ngeocoder.addTo(map);\n&lt;/script&gt;\n[...]\n</code></pre>"},{"location":"documentation/add-search-to-a-map/#search-for-places-on-the-map","title":"Search for places on the map","text":"<p>Now, you will test your search box by finding a few locations. As you type, the text automatically completes to suggest matching results.</p> <ol> <li>On the map, type <code>Seattle University</code> in the Search box.</li> <li> <p>In the results list, find the entry for <code>Seattle University</code> and click it to zoom and add a point to the map at that location. (The point is only on your map, and does not update OpenStreetMap.)</p> <p></p> </li> <li> <p>Search for other addresses or places to experiment with the search function and get an idea of the results it returns. For example, you might try looking for a point of interest in Seattle, your work address, or a city outside the United States.</p> </li> </ol>"},{"location":"documentation/add-search-to-a-map/#customize-the-geocoder","title":"Customize the geocoder","text":"<p>From a technical perspective, Pelias is a web service with that has various API endpoints that allow you to access web resources through a URL. Behind the scenes, the geocoder is constructing a URL with the parameters you specify and sending it to the Pelias web service. The service returns human-readable JSON, short for JavaScript Object Notation.</p> <p>Mapzen.js provides options for customizing the way you interact with the map, and Pelias is also very flexible. Now that you have a map on your page with a Search box, you can add more features to it. You need to modify the line defining the geocoder to include additional parameters.</p> <p>Up to this point, you have been using the Pelias \\autocomplete endpoint, which searches on text as you type it. In this section, you will switch to the \\search endpoint to see how it behaves. The <code>autocomplete</code> functionality helps you find partial matches, whereas <code>search</code> prioritizes exact words because it assumes you have finished typing when you perform the query.</p> <p>If you look at your browser's developer tools console as you are doing this, you can see the query URL changes from <code>https://search.mapzen.com/v1/autocomplete?text=</code> to <code>https://search.mapzen.com/v1/search?text=</code> to reflect the <code>search</code> endpoint.</p> <p>Although you will not be using it in this tutorial, \\reverse is another common Pelias endpoint. It performs reverse geocoding to find the address at a given coordinate location. You can find a listing of all the endpoints and parameters in the Pelias documentation.</p> <ol> <li> <p>Add a variable to allow you to set options for the geocoder. Inside the script tags, and above the geocoder line, add this block.</p> <pre><code>var geocoderOptions = {\nautocomplete: false\n};\n</code></pre> <p>You are setting <code>autocomplete: false</code> to specify that the Search box should not suggest potential text matches as you type. Autocomplete is enabled by default, so adding this means that you will turn it off.</p> </li> <li> <p>Modify the existing geocoder code to pass in the <code>geocoderOptions</code> you set.</p> <pre><code>var geocoder = L.Mapzen.geocoder(geocoderOptions);\n</code></pre> </li> <li> <p>Save your edits and refresh the browser.</p> </li> <li>Type <code>901 12th Avenue</code> in the Search box and press Enter. Notice now that the matching search results are not listed until you press the Enter key.</li> </ol> <p>The code from this section should look something like this.</p> <pre><code>var geocoderOptions = {\nautocomplete: false\n};\nvar geocoder = L.Mapzen.geocoder(geocoderOptions);\ngeocoder.addTo(map);\n</code></pre>"},{"location":"documentation/add-search-to-a-map/#extra-credit-view-the-json-response","title":"Extra credit: View the JSON response","text":"<ol> <li>Open your browser's developer tools console. In Chrome, you can do this by clicking the menu in the corner, pointing to More Tools, and clicking Developer Tools.</li> <li>Click the Network tab to see the Internet traffic, including the queries to the Mapzen servers.</li> <li>Click the Headers tab for more information about the request, including the full URL. For example, the URL might look something like <code>https://search.mapzen.com/v1/search?text=901%2012th%20avenue&amp;focus.point.lat=47.61032944737081&amp;focus.point.lon=-122.31800079345703&amp;api_key=your-mapzen-api-key</code></li> <li>Paste this URL into a new browser tab and use your own API key to see the JSON response, which can be mapped.</li> </ol> <p>Tip: You can install a plug-in for your browser to display JSON in a more formatted manner. You can search the web store for your browser to find and install applicable products.</p> <p></p>"},{"location":"documentation/add-search-to-a-map/#choose-which-data-sources-to-search","title":"Choose which data sources to search","text":"<p>Pelias uses a variety of open data sources, including OpenStreetMap. Part of the power of open data is that anyone can change the source data and improve the quality for everyone. If you are unable to find a location, the place could be missing or incorrect in the source datasets.</p> <p>You can choose which data sources to search by passing a parameter for the <code>sources</code>. In addition, you need to enclose with single quotation marks any parameter names that use the dot notation (such as <code>boundary.country</code>) to make sure JavaScript can parse the text correctly.</p> <p>As you were searching, you might have noticed results that looked similar. Pelias does perform some elimination, but the differing data sources may still cause seemingly matching results to appear. Choosing a particular data source can reduce the occurrence of duplicated entries.</p> <ol> <li> <p>Within the <code>geocoderOptions</code> block, add the <code>params:</code> list and a parameter for <code>sources:</code>. Be sure to add a <code>,</code> at the end of the <code>autocomplete: false</code> line.</p> <pre><code>var geocoderOptions = {\nautocomplete: false,\nparams: {\nsources: 'osm'\n}\n};\n</code></pre> </li> <li> <p>Save your edits and refresh the browser.</p> </li> <li>Search for <code>901 12th Avenue</code> again. Try searching city names, such as <code>Vancouver</code>, as you continue to experiment with the geocoder.</li> </ol>"},{"location":"documentation/add-search-to-a-map/#prioritize-nearby-places-and-filter-search-results","title":"Prioritize nearby places and filter search results","text":"<p>Pelias provides options for customizing your search parameters, such as limiting the search to the map's extent or prioritizing results near the current view. Right now, you may notice that results from around the world appear in the list.</p> <p>Mapzen.js automatically provides a focus point for you based on the current map view extent. You can add other parameters to filter the search results, such as to limit the results to a particular country or type of result.</p> <ol> <li> <p>Within the <code>geocoderOptions</code> block, add add a <code>,</code> at the end of the <code>sources: 'osm'</code> line and then a parameter for <code>'boundary.country': 'USA'</code> on the next line. You need to enclose with single quotation marks any parameter names that use the dot notation (such as <code>boundary.country</code>) to make sure JavaScript can parse the text correctly.</p> <pre><code>var geocoderOptions = {\nautocomplete: false,\nparams: {\nsources: 'osm',\n'boundary.country': 'USA'\n}\n};\n</code></pre> </li> <li> <p>Save your edits and refresh the browser.</p> </li> <li>Search again for city names in the Search box. Notice that you only see results from within the United States. For example, <code>Vancouver</code> in Canada is no longer listed, but you can find the city in Washington.</li> <li>Optionally, trying changing the <code>boundary.country</code> to another country code, such as <code>AUS</code> for Australia. There is a specific format you need to use for the country code. Change the code back to <code>USA</code> when you are done.</li> </ol>"},{"location":"documentation/add-search-to-a-map/#filter-the-results-by-type-of-place","title":"Filter the results by type of place","text":"<p>In Pelias, types of places are referred to as <code>layers</code>, and you can use these to filter your results. For example, if your app has an input form where your users should only be able to enter a city, you can use Pelias to limit the results to show only matching city names. This is common in travel apps, such as searching for a hotel or flight, where you enter a destination city.</p> <p>In this section, you will filter the results to search only addresses and venues, which include point of interest, landmarks, and businesses.</p> <p>You can review the Pelias documentation to learn the types of <code>layers</code> you can use in a search.</p> <ol> <li> <p>Within the <code>geocoderOptions</code> block, add add a <code>,</code> at the end of the <code>'boundary.country: 'USA'</code> line and then a parameter for <code>layers: 'address,venue'</code> on the next line.</p> <p><pre><code>var geocoderOptions = {\nautocomplete: false,\nparams: {\nsources: 'osm',\n'boundary.country': 'USA',\nlayers: 'address,venue'\n}\n};\n</code></pre> 2. Save your edits and refresh the browser. 3. Search for <code>102 Pike Street, Seattle, WA 98101</code> (the first Starbucks) and press Enter. Some other places you can try include <code>Starbucks</code>, <code>400 Broad Street</code> (the address of the Space Needle), <code>Space Needle</code>, and <code>University of Washington</code>.</p> </li> </ol>"},{"location":"documentation/add-search-to-a-map/#tutorial-summary","title":"Tutorial summary","text":"<p>In this tutorial, you learned the basics of adding the Pelias geocoding engine to a map using Mapzen.js, and making some customizations to improve the search results.</p> <p>If you want to learn more about Pelias, review the documentation.</p> <p>Because the geocoder is still under development and considered experimental, if you are getting unexpected search results, please add an issue to the Pelias GitHub repository. The developers can investigate and decide if the problem is caused by software or data, and work to fix it either way.</p>"},{"location":"documentation/add-search-to-a-map/#completed-html-for-this-tutorial","title":"Completed HTML for this tutorial","text":"<p>You can refer to this HTML if you want to review your work or troubleshoot an error.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;title&gt;My Geocoding Map&lt;/title&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://mapzen.com/js/mapzen.css\"&gt;\n&lt;script src=\"https://mapzen.com/js/mapzen.min.js\"&gt;&lt;/script&gt;\n&lt;style&gt;\n#map {\nheight: 100%;\nwidth: 100%;\nposition: absolute;\n}\nhtml,body{margin: 0; padding: 0}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id='map'&gt;&lt;/div&gt;\n&lt;script&gt;\n// Set the global API key\nL.Mapzen.apiKey = \"your-mapzen-api-key\";\n// Add a map to the #map div\n// Center on the Pigott building at Seattle University\nvar map = L.Mapzen.map(\"map\", {\ncenter: [47.61033,-122.31801],\nzoom: 16,\n});\n// Disable autocomplete and set parameters for the search query\nvar geocoderOptions = {\nautocomplete: false,\nparams: {\nsources: 'osm',\n'boundary.country': 'USA',\nlayers: 'address,venue'\n}\n};\n// Add the geocoder to the map, set parameters for geocoder options\nvar geocoder = L.Mapzen.geocoder(geocoderOptions);\ngeocoder.addTo(map);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"documentation/addresses/","title":"Address search accuracy and results","text":"<p>Finding an address is one of the most common functions of a geocoder, but also one of the more complex because of analysis required on the constituent parts of the input text. The search integrates an address-parsing library, known as libpostal, to improve the results when you are looking for an address. In addition, interpolation improves search results when addresses exactly matching the query cannot be found.</p>"},{"location":"documentation/addresses/#accuracy-in-address-results","title":"Accuracy in address results","text":"<p>When finding addresses, you can see an indication of the confidence of the result in the response. The <code>confidence</code> is a numerical value increasing from 0 to 1 that estimates how closely this result matches the query. In relation to an address search, if the input text looks like an address, but the house number of the result does not match the house number that was parsed from the input text, the confidence score is lower.</p> <p>Properties that are related to confidence include <code>accuracy</code> and <code>match_type</code>. The <code>accuracy</code> is an indication of the geometry of the result, which can be either a <code>point</code> or a <code>centroid</code>. The <code>match_type</code> represents the kind of matching that happened for this address. An <code>exact</code> match means the search precisely found your entry, but <code>fallback</code> or <code>interpolated</code> means the result is not exact. The match type is only shown for queries that include an address.</p> <p>Here is an example resulting from a search for the text, <code>30 W 26th street, New York, NY</code>:</p> <pre><code>\"properties\": {\n  [...]\n  \"name\": \"30 West 26th Street\",\n  \"housenumber\": \"30\",\n  \"street\": \"West 26th Street\",\n  \"postalcode\": \"10010\",\n  \"confidence\": 1,\n  \"match_type\": \"exact\",\n  \"accuracy\": \"point\",\n  [...]\n}\n</code></pre> <p>With an accuracy of point and an exact match, the confidence score is closer to 1. You also likely see higher scores with interpolated matches, but the confidence value decreases when centroid accuracy and a fallback match occurs. When that happens, multiple results may be returned so you can choose the one you intended.</p>"},{"location":"documentation/addresses/#address-interpolation","title":"Address interpolation","text":"<p>When you search for an address and and there is not a precise match, the interpolation technique is applied if the street being queried has any address records at all. OpenAddresses and OpenStreetMap, which are the primary sources of addresses in the geocoder, provide locations for hundreds of millions of places globally. These sources, plus address range data from the United States Census Bureau's TIGER product, build a framework for the interpolation, or estimation, of address numbers in areas where there is incomplete data.</p> <p>One form of address interpolation involves drawing a line that connects between the nearest known house numbers and placing the interpolated address within a range on that line. This process may work if the road is straight, but often results in the interpolated point being placed at a distance offset from the road network on curved sections.</p> <p>To improve upon the straight line technique, the Pelias interpolation implementation considers the actual shape of the street when locating a point without a matching address. This results in more accurate location estimation because the interpolated addresses points are placed on the road itself, which also makes it easier for routing and turn-by-turn navigation services to calculate directions for that location.</p> <p>If the address was derived using this technique, you see <code>interpolated</code> for the <code>match_type</code>.</p> <pre><code>},\n\"properties\": {\n  [...]\n  \"name\": \"207 Spear Street\",\n  \"housenumber\": \"207\",\n  \"street\": \"Spear Street\",\n  \"confidence\": 0.8,\n  \"match_type\": \"interpolated\",\n  \"accuracy\": \"point\",\n  [...]\n}\n</code></pre>"},{"location":"documentation/addresses/#partial-matches-and-fallbacks","title":"Partial matches and fallbacks","text":"<p>In some scenarios, good matches cannot be found for what you enter, so fallback behavior occurs. Some examples where this occurs includes if a street is misspelled, the street name changes (such as <code>West Broadway</code> turns into <code>East Main Street</code>), or the street name does not exist in a city.</p> <p>When this happens, the approach is to first try the most specific combination of analyzed fields, then fall back to coarser combinations until a result is returned. For example, if you enter a street address that is not in the city you specified, the house number and street are dropped, and the search attempts to match the city and state names only.</p> <p>The search currently supports only address points and not house number interpolation. This means that if a house number is not an address point in the data being searched, the behavior is to fall back to the street name. For example, <code>32 W 26th Street, New York, NY</code> is not an address point in the available data, but <code>W 26th Street, New York, NY</code> does exist. Therefore, only a street result is returned.</p> <p>Sometimes the search input contains a street, city, and state but the street is either misspelled or does not exist in the city. For example, if you enter <code>Calle de Lago, New York, NY</code>, the <code>Calle de Lago</code> is identified as a street, but one that does not exist in New York City. When the street lookup fails, the city is returned.</p> <p>If you enter a city that is not found in a particular state, the results will fall back to the state name you entered. Similar behavior happens for provinces and other administrative regions around the world.</p>"},{"location":"documentation/addresses/#poor-address-search-results","title":"Poor address search results","text":"<p>If the search is unable to return any results based on the address, it functions more as a geographic search engine than a geocoder. When this happens, you may see fuzzy text-matching behavior. For example, the input <code>10 Main Street, United States of America</code> is parsed as a street and country but the search only supports <code>United States</code> and <code>USA</code>, so no results would be returned.  In this case, you may see results that match some of the inputs, including <code>10 Main Street, Fair Haven, VT, USA</code> and <code>10 Main Street, Swanland, England, United Kingdom</code>.</p>"},{"location":"documentation/autocomplete/","title":"Search with autocomplete","text":"<p>If you are building an end-user application, you can use the <code>/autocomplete</code> endpoint alongside <code>/search</code> to enable real-time feedback. This type-ahead functionality helps users find what they are looking for, without requiring them to fully specify their search term. Typically, the user starts typing and a drop-down list appears where they can choose the term from the list below.</p> <p>To build a query with autocomplete, you need a <code>text</code> parameter, representing what a user has typed into your application so far. Optionally, you can specify a geographic point where the search is focused, this will allow users to see more local places in the results.</p>"},{"location":"documentation/autocomplete/#user-experience-guidelines","title":"User experience guidelines","text":"<p>There are several user experience pitfalls to watch out for when implementing a client-side typeahead solution:</p>"},{"location":"documentation/autocomplete/#requests-must-be-throttled","title":"Requests must be throttled","text":"<p>Since autocomplete requests generally correspond directly to user input, it's important to account for fast typers and throttle requests. Some devices and networks (for example, mobile phones on a slow connection) may respond poorly when too many requests are sent too quickly, so be sure to do some testing on your own. Learn more in this interactive demo.</p> <p>Our testing shows that between 5 and 10 requests per second is the range with the best balance of resource usage and autocomplete responsiveness.</p> <p>Many Pelias services also enforce hard per-second rate limits, so setting a client-side throttle can help you avoid exceeding those limits. It's better to send fewer requests on your own terms than rely on a server's rate limiting to decide which requests will receive a complete response.</p>"},{"location":"documentation/autocomplete/#account-for-asynchronous-out-of-order-responses","title":"Account for asynchronous, out of order responses","text":"<p>You cannot be sure responses will be returned in the same order they were requested. If you were to send two queries synchronously, first <code>'Lo'</code> then <code>'London'</code>, you may find the <code>'London'</code> response would arrive before the <code>'Lo'</code> response. This will result in a quick flash of <code>'London'</code> results followed by the results for <code>'Lo'</code>, which can confuse the user.</p> <p>Autocomplete requests with more characters typed will often return faster, since the search space of the query is smaller, so this is not an edge case.</p>"},{"location":"documentation/autocomplete/#use-search-even-with-autocomplete","title":"Use search even with autocomplete","text":"<p>While the autocomplete endpoint is designed specifically for use with user-entered inputs, the search endpoint can still be useful in certain situations. A common paradigm is to send an autocomplete request on key presses (throttling appropriately as described earlier), but sending a search request when the user hits the <code>enter</code> key or a submit button.</p> <p>This approach allows for the speed and partial-input handling of the autocomplete endpoint to be used when needed, and the accuracy and additional functionality of the search endpoint to be used when possible.</p> <p>In our experience, most users have been trained by other websites that submit buttons paired with an autocomplete interface will trigger a \"more in depth\" search, and so will naturally use this ability.</p>"},{"location":"documentation/autocomplete/#use-a-pre-written-client-library-if-possible","title":"Use a pre-written client library if possible","text":"<p>If you are already using Leaflet, we recommend using the Nextzen (previously Mapzen) leaflet-geocoder plugin. This plugin follows all the autocomplete guidelines listed here and has been well vetted by many members of our community.</p>"},{"location":"documentation/autocomplete/#set-the-number-of-results-returned","title":"Set the number of results returned","text":"<p>By default, Pelias results up to 10 places, unless otherwise specified. If you want a different number of results, set the <code>size</code> parameter to the desired number. This example shows returning only the first result.</p> parameter value <code>text</code> YMCA <code>size</code> 1 <p>/v1/autocomplete?text=YMCA&amp;size=1</p> <p>If you want 25 results, you can build the query where <code>size</code> is 25.</p> <p>/v1/autocomplete?text=YMCA&amp;size=25</p>"},{"location":"documentation/autocomplete/#global-scope-local-focus","title":"Global scope, local focus","text":"<p>To focus your search based upon a geographical area, such as the center of the user's map or at the device's GPS location, supply the parameters <code>focus.point.lat</code> and <code>focus.point.lon</code>. This boosts locally relevant results higher. For example, if you search for <code>Union Square</code>:</p> <p>From San Francisco:</p> <p>/v1/autocomplete?focus.point.lat=37.7&amp;focus.point.lon=-122.4&amp;text=union square</p> <pre><code>1)  Union Square, San Francisco County, CA\n2)  Union Square, New York County, NY\n</code></pre> <p>From New York City:</p> <p>/v1/autocomplete?focus.point.lat=40.7&amp;focus.point.lon=-73.9&amp;text=union square</p> <pre><code>1)  Union Square, New York County, NY\n2)  Union Square, San Francisco County, CA\n</code></pre> <p>The <code>/autocomplete</code> endpoint can promote nearby results to the top of the list, while still allowing important matches from farther away to be visible. For example, searching <code>hard rock cafe</code> with a focus on Berlin:</p> <p>/v1/autocomplete?focus.point.lat=52.5&amp;focus.point.lon=13.3&amp;text=hard rock cafe</p> <p>with <code>focus.point</code> you will find the Berlin restaurant first: <pre><code>1)  Hard Rock Cafe Berlin, Berlin, Germany\n2)  Hard Rock Caf\u00e9, San Giljan, Malta\n</code></pre></p> <p>without <code>focus.point</code> you will find the most popular restaurants first: <pre><code>1)  Hard Rock Cafe, Pune, Maharashtra\n2)  Hard Rock Caf\u00e9, San Giljan, Malta\n</code></pre></p>"},{"location":"documentation/autocomplete/#filters","title":"Filters","text":"<p>You can filter the results in several ways: the original data source and/or the type of record.</p>"},{"location":"documentation/autocomplete/#sources","title":"Sources","text":"<p>The <code>sources</code> parameter allows you to specify from which data sources you'd like to receive results. The sources are as follows</p> <ul> <li><code>openstreetmap</code> or <code>osm</code></li> <li><code>openaddresses</code> or <code>oa</code></li> <li><code>geonames</code> or <code>gn</code></li> <li><code>whosonfirst</code> or <code>wof</code></li> </ul> <p>/v1/autocomplete?sources=openaddresses&amp;text=pennsylvania</p> <p>with <code>sources=openaddresses</code> you will only find addresses on Pennsylvania Ave or Street: <pre><code>1) 8 R Pennsylvania Avenue, Amity, PA, USA\n2) 7 Pennsylvania Avenue, Amity, PA, USA\n3) 9 Pennsylvania Avenue, Cherry, PA, USA\n</code></pre></p> <p>without <code>sources=openaddresses</code> you will find the most popular Pennsylvanias first: <pre><code>1) Pennsylvania, USA\n2) Pennsylvania Avenue Heights, Washington, DC, USA\n3) Pennsylvania, Satsuma, AL, USA\n</code></pre></p>"},{"location":"documentation/autocomplete/#layers","title":"Layers","text":"<p>The type of record is referred to as its <code>layer</code>. All records are indexed into the following layers:</p> layer description <code>venue</code> points of interest, businesses, things with walls <code>address</code> places with a street address <code>street</code> streets,roads,highways <code>country</code> places that issue passports, nations, nation-states <code>macroregion</code> a related group of regions. Mostly in Europe <code>region</code> states and provinces <code>macrocounty</code> a related group of counties. Mostly in Europe. <code>county</code> official governmental area; usually bigger than a locality, almost always smaller than a region <code>locality</code> towns, hamlets, cities <code>localadmin</code> local administrative boundaries <code>borough</code> a local administrative boundary, currently only used for New York City <code>neighbourhood</code> social communities, neighbourhoods <code>coarse</code> alias for simultaneously using all administrative layers (everything except <code>venue</code> and <code>address</code>) <code>postalcode</code> postal code used by mail services <p>/v1/autocomplete?layers=coarse&amp;text=starbuck</p> <p>with <code>layers=coarse</code> you will see only administrative areas with names containing Starbuck</p> <pre><code>1) Starbuckville, NY, USA\n2) Starbuck, MN, USA\n3) Starbuck, WA, USA\n</code></pre> <p>with <code>layers=venue</code> you will see only the venues by that name</p> <pre><code>1) Starbucks, Braunschweig, Germany\n2) Starbucks, Islip, NY, USA\n3) Starbucks, Austin, TX, USA\n</code></pre>"},{"location":"documentation/autocomplete/#search-within-a-circular-region","title":"Search within a circular region","text":"<p>Sometimes you don't have a rectangle to work with, but rather you have a point on earth\u2014for example, your location coordinates\u2014and a maximum distance within which acceptable results can be located.</p> <p>In this example, you want to find all YMCA locations within a 35-kilometer radius of a location in Ontario, Canada. This time, you can use the <code>boundary.circle.*</code> parameter group, where <code>boundary.circle.lat</code> and <code>boundary.circle.lon</code> is your location in Ontario and <code>boundary.circle.radius</code> is the acceptable distance from that location. Note that the <code>boundary.circle.radius</code> parameter is always specified in kilometers.</p> <p>/v1/autocomplete?text=YMCA&amp;boundary.circle.lon=-79.186484&amp;boundary.circle.lat=43.818156&amp;boundary.circle.radius=35</p> parameter value <code>text</code> YMCA <code>boundary.circle.lat</code> 43.818156 <code>boundary.circle.lon</code> -79.186484 <code>boundary.circle.radius</code> 35 <p>You can see the results have fewer than the standard 10 items because there are not that many YMCA locations in the specified radius:</p> <ul> <li>YMCA, Toronto, Ontario</li> <li>YMCA, Markham, Ontario</li> <li>YMCA, Toronto, Ontario</li> <li>Metro Central YMCA, Toronto, Ontario</li> <li>Pinnacle Jr YMCA, Toronto, Ontario</li> <li>Cooper Koo Family Cherry Street YMCA Centre, Toronto, Ontario</li> </ul>"},{"location":"documentation/autocomplete/#country","title":"Country","text":"<p>Sometimes your work might require that all the search results be from a particular country or a list of countries. To do this, you can set the <code>boundary.country</code> parameter value to a comma separated list of alpha-2 or alpha-3 ISO-3166 country code.</p>"},{"location":"documentation/autocomplete/#available-autocomplete-parameters","title":"Available autocomplete parameters","text":"Parameter Type Required Default Example <code>text</code> string yes none <code>Union Square</code> <code>focus.point.lat</code> floating point number no none <code>48.581755</code> <code>focus.point.lon</code> floating point number no none <code>7.745843</code> <code>boundary.rect.min_lon</code> floating point number no none <code>139.2794</code> <code>boundary.rect.max_lon</code> floating point number no none <code>140.1471</code> <code>boundary.rect.min_lat</code> floating point number no none <code>35.53308</code> <code>boundary.rect.max_lat</code> floating point number no none <code>35.81346</code> <code>boundary.circle.lat</code> floating point number no none <code>43.818156</code> <code>boundary.circle.lon</code> floating point number no none <code>-79.186484</code> <code>boundary.circle.radius</code> floating point number no 50 <code>35</code> <code>sources</code> string no all sources: osm,oa,gn,wof openstreetmap,wof <code>layers</code> string no all layers: address,venue,neighbourhood,locality,borough,localadmin,county,macrocounty,region,macroregion,country,coarse,postalcode address,venue <code>boundary.country</code> string no none <code>GBR,FRA</code> <code>boundary.gid</code> Pelias <code>gid</code> no none <code>whosonfirst:locality:101748355</code> <code>size</code> integer no 10 20"},{"location":"documentation/data-sources/","title":"Data sources with supported importers","text":"<p>Pelias is built with a mostly data-agnostic architecture: any datasource that can be converted into the Elasticsearch document format used by Pelias can be imported and geocoded against. Of course, building a good importer takes time. Pelias currently has official support for five importers from four different open data projects. We owe a tremendous debt of gratitude to the individuals and communities which produced these datasets.</p> <p>Attribution is required for many of data providers. Some license information is listed here, but you are responsible for researching each project to follow their license terms.</p>"},{"location":"documentation/data-sources/#openaddresses","title":"OpenAddresses","text":"<p>OpenAddresses is a collection of over 300 million addresses around the world. Data in OpenAddresses only comes from national, state, and local governments, so this data is highly authoritative. Because it consists of entirely bulk imports, OpenAddresses is a large, global, and rapidly growing dataset. Many countries, particularly in Europe, now have every address represented in OpenAddresses.</p> <p>OpenAddresses is by far the largest dataset by number of records used by Pelias. Even though it only contains address data (as in no building names or other metadata), it's a great resource for global geocoding.</p> <p>The license for each individual source within OpenAddresses differs. Many of the sources require attribution, and many others have a share-alike clause. Note: Pelias does not currently return license information directly, but the license and attribution requirements for each source within OpenAddresses can be determined from the machine-readable state.txt file published on the OpenAddresses website.</p>"},{"location":"documentation/data-sources/#whos-on-first","title":"Who's on First","text":"<p>Who's on First is an open-data directory of worldwide administrative places. Originally started at Mapzen, it is the primary provider of:</p> <ul> <li>Countries</li> <li>Macroregions (for example, England is a Macroregion within the United Kingdom)</li> <li>Regions (for example, states, provinces)</li> <li>Macro-counties (for example, Departments of France)</li> <li>Counties</li> <li>Localities (cities, towns, hamlets)</li> <li>Neighbourhoods</li> </ul> <p>Additionally, for addresses, venues, and points of interest coming from OpenStreetMap, Geonames, and OpenAddresses, Pelias uses Who's on First to provide standardized fields for the country, region, locality, and neighbourhood.</p> <p>License</p>"},{"location":"documentation/data-sources/#openstreetmap","title":"OpenStreetMap","text":"<p>OpenStreetMap is a community-driven, editable map of the world. It prioritizes local knowledge and individual contributions over bulk imports, which often means it has excellent coverage even in remote areas where no large-scale mapping efforts have been attempted. OpenStreetMap contains information on landmarks, buildings, roads, and natural features.</p> <p>With its coverage of roads as well as rich metadata, OpenStreetMap is arguably the most valuable dataset used by Pelias for general usage.</p> <p>All OpenStreetMap data is licensed under the ODbL, a share-alike license which also requires attribution.</p> <p>Note: There are two importers for OSM data. The main importer, pelias/openstreetmap, handles venues and addresses. The pelias/polylines importer handles streets, since dealing with line geometry is a special challenge.</p>"},{"location":"documentation/data-sources/#geonames","title":"Geonames","text":"<p>Geonames is an aggregation of many authoritative and non-authoritative datasets. It contains information on everything from country borders to airport names to geographical features. While Geonames does not contain any shape data (such as country borders), it does have a powerful and well defined hierarchy to describe the relationships between different records. This custom hierarchy makes it harder to use in combination with data from other sources, but the  Who's On First project will help by providing concordance between Geonames and other datasets.</p> <p>In the meantime, Geonames still provides a wide variety of useful data that helps augment the other datasets used by Pelias.</p> <p>Geonames data is licensed CC-BY-3.0.</p>"},{"location":"documentation/data-sources/#deprecated-sources","title":"Deprecated sources","text":"<p>Certain data sources used to be supported by Pelias but are no longer offered part of the core service and have been superseded by a new data source.</p>"},{"location":"documentation/data-sources/#quattroshapes","title":"Quattroshapes","text":"<p>Quattroshapes used to be supported by Pelias and its use was discontinued in April 2016. The importer can still be found at pelias-deprecated/quattroshapes.</p> <p>It has been replaced by Who's on First, which continues to provide global administrative place data (countries, regions, counties, cities) and administrative lookup (\"what country, region, and city is this address part of?\").</p> <p>To help make the transition seamless, any queries that specify quattroshapes in the <code>sources</code> parameter will see results from Who's on First instead. Who's on First contains all the data from Quattroshapes, plus more data, and has continuous updates and fixes. All existing queries for Quattroshapes will continue to work without modification.</p> <p>Quattroshapes data is licensed CC-BY-2.0.</p>"},{"location":"documentation/full-planet-considerations/","title":"Considerations for full-planet builds","text":"<p>Pelias is designed to work with data ranging from a small city to the entire planet. Small cities do not require particularly significant resources and should work out of the box on even modest personal computers. However, full planet builds present many of their own challenges and require planning regarding compute infrastructure in order to have success.</p> <p>Current full planet builds weigh in at over 600 million documents, and require about 450GB total storage in Elasticsearch.</p> <p>The best performance for full planet import comes when using a single machine with fast, local NVMe SSDs, a fast internet connection for downloading data, and many CPUs for parallel processing.</p> <p>To set expectations, a 36 core machine can complete a Pelias build in about 16 hours.</p>"},{"location":"documentation/full-planet-considerations/#recommended-processes","title":"Recommended processes","text":""},{"location":"documentation/full-planet-considerations/#use-docker-containers-and-orchestration","title":"Use Docker containers and orchestration","text":"<p>We strongly recommend using Docker (either through our provided pelias/docker repository or otherwise) to run Pelias. All our services include Dockerfiles and the resulting images are pushed to Docker Hub by our CI. Using these images will drastically reduce the amount of work it takes to set up Pelias and will ensure you are on a known good configuration, minimizing the number of issues you will encounter.</p> <p>Additionally, there are many great tools for managing container workloads. Simple ones like docker-compose can be used for small installations, and more complex tools like Kubernetes can be great for larger installations. Pelias is extensively tested on both.</p>"},{"location":"documentation/full-planet-considerations/#use-separate-pelias-installations-for-indexing-and-production-traffic","title":"Use separate Pelias installations for indexing and production traffic","text":"<p>The requirements for performant and reliable Elasticsearch clusters are very different for importing new data compared to serving queries. It is highly recommended to use one cluster to do imports, save the resulting Elasticsearch index into a snapshot, and then load that snapshot into the cluster used to perform actual geocoding.</p>"},{"location":"documentation/full-planet-considerations/#shard-count","title":"Shard count","text":"<p>Shard count is a balance between several factors. In general, higher shard counts allow more parallelism, at the cost of slightly lower efficiency.</p> <p>The latest guidance from the Elasticsearch team is that shards should be no larger than 50GB, but otherwise having as few shards as possible is best. The most well tested full planet build configuration is to use 12 shards. If you run performance comparisons at different shard counts, be sure to share your findings!</p> <p>The <code>elasticsearch</code> section of <code>pelias.json</code> can be used to configure the shard count.</p> <pre><code>{\n\"elasticsearch\": {\n\"settings\": {\n\"index\": {\n\"number_of_shards\": \"5\",\n}\n}\n}\n}\n</code></pre>"},{"location":"documentation/full-planet-considerations/#elasticsearch-heap-size","title":"Elasticsearch Heap Size","text":"<p>The elasticsearch heap size can be set in docker-compose.yaml.</p> <pre><code>  elasticsearch:\n    environment: [ \"ES_JAVA_OPTS=-Xmx8g\" ]\n</code></pre> <p>8GB is a well proven heap size for a full planet build. It meets the official recommendations from Elastic: big enough to fit all required data, but small enough to avoid long garbage collection times, and under the 31GB threshold where JVM memory usage becomes less efficient.</p>"},{"location":"documentation/full-planet-considerations/#force-merge-your-elasticsearch-indices","title":"Force merge your Elasticsearch indices","text":"<p>Pelias Elasticserach indices are generally static, as we do not recommend querying from and importing to an Elasticsearch cluster simultaneously. In such cases, the highest levels of performance can be achieved by force-merging the Elasticsearch index.</p> <p>This process takes a while, around 5 hours in our experience, but for a snapshot that will be queried heavily later, it can be worth it.</p>"},{"location":"documentation/full-planet-considerations/#recommended-hardware","title":"Recommended hardware","text":"<p>For a production ready instance of Pelias, capable of supporting a few hundred queries per second across a full planet build, a setup like the following should be sufficient.</p>"},{"location":"documentation/full-planet-considerations/#elasticsearch-cluster-for-importing","title":"Elasticsearch cluster for importing","text":"<p>The main requirement of Elasticsearch is that it has enough disk for a full build. 600GB across the cluster is a good minimum. Increased CPU power is useful to achieve a higher throughput for queries: a full planet build with all importers running in parallel can easily utilize 16 cores or more.</p>"},{"location":"documentation/full-planet-considerations/#elasticsearch-cluster-for-querying","title":"Elasticsearch cluster for querying","text":"<p>For queries, essentially the only bottleneck is CPU, although more RAM is helpful so Elasticsearch data can be cached. On AWS, <code>c5</code> instances are significantly more performant than even the <code>c4</code> instances, and should be used if high performance is needed.</p> <p>Example configuration: 2 <code>m5.2xlarge</code> (8 CPU, 32GB RAM) to serve 250 RPS</p>"},{"location":"documentation/full-planet-considerations/#importer-machine","title":"Importer machine","text":"<p>The importers are each single-threaded Node.js processes, which require around 8GB of RAM each with admin lookup enabled. Faster CPUs will help increase the import speed. Running multiple importers in parallel is recommended if the importer machine has enough RAM and CPU to support them.</p> <p>Example configuration: 1 <code>c5.9xlarge</code> (36 CPU, 72GB RAM), running all importers in parallel</p>"},{"location":"documentation/full-planet-considerations/#pelias-services","title":"Pelias services","text":"<p>Each Pelias service has different memory and CPU requirements. Here are some rough guidelines:</p>"},{"location":"documentation/full-planet-considerations/#api","title":"API","text":"<ul> <li>RAM: 200MB per instance</li> <li>CPU: Single threaded, one instance can serve at least 500 RPS</li> <li>Disk: None</li> </ul>"},{"location":"documentation/full-planet-considerations/#placeholder","title":"Placeholder","text":"<ul> <li>RAM: 200MB per instance</li> <li>CPU: Single threaded, supports clustering</li> <li>Disk: Requires about 5GB for a full planet SQLite DB</li> </ul>"},{"location":"documentation/full-planet-considerations/#libpostal","title":"Libpostal","text":"<ul> <li>RAM: 3GB per instance</li> <li>CPU: Multi-threaded, and extremely fast. A single core can serve 8000+ RPS</li> <li>Disk: about 4GB of data storage required</li> </ul>"},{"location":"documentation/full-planet-considerations/#pip","title":"PIP","text":"<ul> <li>RAM: ~8GB</li> <li>CPU: 2 cores per instance recommended. Cannot effectively use more than 2 cores, but will serve at least 7000RPS</li> <li>Disk: A full planet Who's on First SQLite DB requires about 30GB</li> </ul>"},{"location":"documentation/full-planet-considerations/#interpolation","title":"Interpolation","text":"<ul> <li>RAM: 3GB per instance currently (please follow our efforts to un-bundle libpostal from the interpolation service)</li> <li>CPU: Single core. One instance can serve around 200RPS</li> <li>Disk: 50GB needed for a full planet interpolation dataset</li> </ul>"},{"location":"documentation/getting-started-install/","title":"Getting Started","text":""},{"location":"documentation/getting-started-install/#getting-started-with-pelias","title":"Getting started with Pelias","text":"<p>Looking to install and set up Pelias? You've come to the right place. We have several different tools and pieces of documentation to help you.</p>"},{"location":"documentation/getting-started-install/#installing-for-the-first-time","title":"Installing for the first time?","text":"<p>We strongly recommend using our Docker based installation for your first install. It removes the need to deal with most of the complexity and dependencies of Pelias. On a fast internet connection you should be able to get a small city like Portland, Oregon installed in under 30 minutes.</p>"},{"location":"documentation/getting-started-install/#want-to-go-more-in-depth","title":"Want to go more in depth?","text":"<p>The Pelias docker installation should work great for any small area, and is great for managing the different Pelias services during development. However, we understand not everyone can or wants to use Docker, and that people want more details on how things work.</p> <p>For this, we have our from scratch installation guide</p>"},{"location":"documentation/getting-started-install/#installing-in-production","title":"Installing in production?","text":"<p>By far the most well tested way to install Pelias is to use Kubernetes. Kubernetes is perfect for managing systems that have many different components, like Pelias.</p> <p>We would love to add additional, well tested ways to install Pelias in production. Reach out to us if you have something to share or want to get started.</p>"},{"location":"documentation/getting-started-install/#doing-a-full-planet-build","title":"Doing a full planet build?","text":"<p>Running Pelias for a city or small country is pretty easy. However, due to the amount of data involved, a full planet build is harder to pull off.</p> <p>See our full planet build guide for some recommendations on how to make it easier and more performant.</p>"},{"location":"documentation/glossary/","title":"Pelias glossary","text":""},{"location":"documentation/glossary/#common-search-and-geocoding-terms","title":"Common search and geocoding terms","text":"<ul> <li>geocoding - the process of converting an address or the name of a landmark or business into a latitude, longitude pair. Sometimes referred to as forward geocoding. Use the <code>search</code> endpoint to do this.</li> <li>reverse geocoding - the process of converting a latitude, longitude pair into the name and address of the nearest place. Use the <code>reverse</code> endpoint to do this.</li> <li>coarse geocoding - adds regions and administrative boundaries to the geocoding process. Coarse forward geocoding limits a search to a particular region, while coarse reverse geocoding converts a geographic coordinate pair into the administrative boundary hierarchy containing it, such as from the neighbourhood to the local administrative area, and on up to the country level.</li> <li>administrative area - a catch-all term for any area that might sub-divide the world, such as a city, neighbourhood, country, continent, etc. Usually, but not always, these correspond to various government administrations, hence administrative area.</li> <li>gazetteer - a directory of geographical places, with a stable identifier and some number of descriptive properties about that location.</li> </ul>"},{"location":"documentation/glossary/#pelias-api-and-developer-terms","title":"Pelias API and developer terms","text":"<ul> <li>API endpoint - an architectural style for accessing web resources through a URL. In Pelias, available endpoints include <code>search</code>, <code>reverse</code>, and <code>autocomplete</code>. You can construct a URL to send queries and receive responses from Pelias.</li> <li>autocomplete - enables real-time feedback when entering text for a search, typically, where users start typing and a drop-down list appears where they can choose the term from the list below. Use the <code>autocomplete</code> endpoint to do this.</li> <li>data source - the datasets available to Pelias. Only data sources that have open-source licenses are used.</li> <li>focus - option to make places closer to a particular location be prioritized and appear higher in the search results list. After all nearby results have been found, additional results will come from the rest of the world, without any further location-based prioritization.</li> <li>layer - types of places available to Pelias and arranged in a hierarchy, such as an address, a venue, a neighbourhood, or a country.</li> <li><code>place</code> search - get details on a place if you know the data source, the type of place (such as a venue or address), and the identification number.</li> <li>structured geocoding - Assigns geographical coordinates to an address, venue, or other location type that has been broken up into its constituent parts. Use the <code>search/structured</code> endpoint to do this.</li> </ul>"},{"location":"documentation/glossary/#other-mapping-terms","title":"Other mapping terms","text":"<ul> <li>bounding box - a rectangular area defined by two longitudes and two latitudes (the minimum and the maximum latitude, longitude).</li> <li>cross-origin resource sharing (CORS) - standard allowing a web browser and server to accept requests across domains. Without CORS, browsers may not allow cross-site requests because they could be malicious.</li> <li>latitude - the distance of a point north or south of the equator. In Pelias, latitudes are expressed in decimal degrees.</li> <li>longitude - the distance of a point east or west. In Pelias, longitudes are in relation to the Prime Meridian and expressed in decimal degrees.</li> </ul>"},{"location":"documentation/http-status-codes/","title":"HTTP status codes","text":""},{"location":"documentation/http-status-codes/#geocoding","title":"Geocoding","text":"<p>The following status codes are returned from the geocoding service:</p> <ul> <li><code>200 OK</code>: The request has succeeded.</li> <li><code>400 Bad Request</code>: An input parameter was invalid. An error message is included in the response body with more details.</li> <li><code>404 Not Found</code>: The URL is invalid or the path is no longer valid.</li> <li><code>408 Request Timeout</code>: The Elasticsearch cluster took too long to respond.</li> <li><code>500 Internal Server Error</code>: Generic fatal error.</li> <li><code>502 Bad Gateway</code>: Connection was lost to the Elasticsearch cluster.</li> </ul> <p>In all cases above, the response body will be valid GeoJSON.</p>"},{"location":"documentation/language-codes/","title":"Get search results in a particular language","text":"<p>You can get search results in another language, if available, by specifying a target language code with your request.</p> <p>By default, search responses are in the default locale of the dataset. However, if you include a language code, the search attempts to return place names in the language you specified.</p> <p>If the language you requested is unavailable, then the default language is returned. In some cases, this is the local dialect, or it may be English for other datasets.</p>"},{"location":"documentation/language-codes/#request-a-specific-language","title":"Request a specific language","text":"<p>You can specify the target language code in the BCP47 standard as either a query string URL parameter or an HTTP header.</p> <p>Note that a language code in the query string takes precedence over a code in the header. If you include an invalid language code, then you see a warning message and the search attempts to find a valid code, if one is available. Otherwise, the results fall back to default behavior.</p> <p>BCP47 language tags can contain three parts:</p> <ol> <li>A language subtag (en, zh).</li> <li>A script subtag (Hant, Latn).</li> <li>A region subtag (US, CN).</li> </ol> <p>At this time, only the <code>language subtag</code> information is used to set the target language. The other options may be enabled in the future when additional data can be imported with text containing <code>script subtag</code> and <code>region subtag</code> variants.</p>"},{"location":"documentation/language-codes/#set-language-as-a-query-string-in-the-url","title":"Set language as a query string in the URL","text":"<p>You can specify the language code using a URL parameter named <code>lang</code>: <code>/v1/search?lang=de-ch</code>.</p>"},{"location":"documentation/language-codes/#set-language-in-the-http-header","title":"Set language in the HTTP header","text":"<p>You can include the language code in the HTTP request header with the <code>Accept-Language</code> parameter: <code>Accept-Language: de-ch</code>.</p>"},{"location":"documentation/language-codes/#language-properties-in-the-response","title":"Language properties in the response","text":"<p>The response contains information about the language being returned, which can be helpful for debugging.</p> <pre><code>{\n  \"geocoding\": {\n      [...]\n      \"lang\": {\n        \"name\": \"German\",\n        \"iso6391\": \"de\",\n        \"iso6393\": \"deu\",\n        \"defaulted\": false\n      },\n      [...]\n    },\n[...]\n</code></pre> <p>The language items include:</p> <ul> <li><code>name</code>: a human-readable name for the language, in English</li> <li><code>iso6391</code> and <code>iso6393</code>: the language code as defined in the two most common standards</li> <li><code>defaulted</code>: a value of <code>true</code> or <code>false</code> to indicate if there was a fall-back to a default language property</li> </ul>"},{"location":"documentation/pelias-from-scratch/","title":"Installing Pelias from Scratch","text":"<p>These instructions will help you set up the Pelias geocoder from scratch. We strongly recommend using our Docker tools for your first Pelias installation.</p> <p>However, for more in-depth usage, or to learn more about the internals of Pelias, use this guide.</p> <p>It assumes some knowledge of the command line and Node.js, but we'd like as many people as possible to be able to install Pelias, so if anything is confusing, please don't hesitate to reach out. We'll do what we can to help and also improve the documentation.</p>"},{"location":"documentation/pelias-from-scratch/#installation-overview","title":"Installation Overview","text":"<p>These are the steps for fully installing Pelias: 1. Check that the hardware and software requirements are met 1. Decide which datasets to use and download them 1. Download the Pelias code 1. Customize Pelias Configuration file <code>~/pelias.json</code> 1. Install the Elasticsearch schema using pelias-schema 1. Use one or more importers to load data into Elasticsearch 1. Install and start the Pelias services 1. Start the API server to begin handling queries</p>"},{"location":"documentation/pelias-from-scratch/#system-requirements","title":"System Requirements","text":"<p>See our software requirements and insure all of them are installed before moving forward</p>"},{"location":"documentation/pelias-from-scratch/#hardware-recommendations","title":"Hardware recommendations","text":"<ul> <li>At a minimum 50GB disk space to download, extract, and process data</li> <li>8GB RAM for a local build, 16GB+ for a full planet build. Pelias needs a little RAM for Elasticsearch, but much more for storing administrative data during import</li> <li>As many CPUs as you can provide. There's no minimum, but Pelias builds are highly paralellizable, so more CPUs will help make it faster.</li> </ul>"},{"location":"documentation/pelias-from-scratch/#choose-your-datasets","title":"Choose your datasets","text":"<p>Pelias can currently import data from four different sources, using five different importers.</p> <p>Only one dataset is required: Who's on First. This dataset is used to enrich all data imported into Pelias with administrative information. For more on this process, see the wof-admin-lookup documentation.</p> <p>Note: You don't have to run the <code>whosonfirst</code> importer, but you do have to have Who's on First data available on disk for use by the other importers.</p> <p>Here's an overview of how to download each dataset.</p>"},{"location":"documentation/pelias-from-scratch/#whos-on-first","title":"Who's on First","text":"<p>The Who's on First importer can download all the Who's on First data quickly and easily.</p>"},{"location":"documentation/pelias-from-scratch/#geonames","title":"Geonames","text":"<p>The pelias/geonames importer contains code and instructions for downloading Geonames data automatically. Individual countries, or the entire planet (1.3GB compressed) can be specified.</p>"},{"location":"documentation/pelias-from-scratch/#openaddresses","title":"OpenAddresses","text":"<p>The Pelias Openaddresses importer can download specific files from OpenAddresses.</p> <p>Additionally, the OpenAddresses project includes numerous download options, all of which are <code>.zip</code> downloads. The full dataset is just over 6 gigabytes compressed (the extracted files are around 30GB), but there are numerous subdivision options.</p>"},{"location":"documentation/pelias-from-scratch/#openstreetmap","title":"OpenStreetMap","text":"<p>OpenStreetMap (OSM) has a nearly limitless array of download options, and any of them should work as long as they're in PBF format. Generally the files will have the extension <code>.osm.pbf</code>. Good sources include download.geofabrik.de, Nextzen Metro Extracts, Interline OSM Extracts, and planet files listed on the OSM wiki. A full planet PBF file is about 41GB.</p>"},{"location":"documentation/pelias-from-scratch/#street-data-polylines","title":"Street Data (Polylines)","text":"<p>To download and import street data from OSM, a separate importer is used that operates on a preprocessed dataset derived from the OSM planet file.</p>"},{"location":"documentation/pelias-from-scratch/#installation","title":"Installation","text":""},{"location":"documentation/pelias-from-scratch/#download-the-pelias-repositories","title":"Download the Pelias repositories","text":"<p>At a minimum, you'll need 1. Pelias schema 2. The Pelias API and other Pelias services 3. Importer(s)</p> <p>Here's a bash snippet that will download all the repositories (they are all small enough that you don't have to worry about the space of the code itself) and install all the node module dependencies.</p> <pre><code>for repository in schema whosonfirst geonames openaddresses openstreetmap polylines api placeholder interpolation pip-service; do\ngit clone https://github.com/pelias/${repository}.git # clone from Github\npushd $repository &gt; /dev/null                         # switch into importer directory\nnpm install                                           # install npm dependencies\npopd &gt; /dev/null                                      # return to code directory\ndone\n</code></pre>"},{"location":"documentation/pelias-from-scratch/#customize-pelias-config","title":"Customize Pelias Config","text":"<p>Nearly all configuration for Pelias is driven through a single config file: <code>pelias.json</code>. By default, Pelias will look for this file in your home directory, but you can configure where it looks. For more details, see the pelias-config repository.</p>"},{"location":"documentation/pelias-from-scratch/#where-on-the-network-to-find-elasticsearch","title":"Where on the network to find Elasticsearch","text":"<p>Pelias will by default look for Elasticsearch on <code>localhost</code> at port 9200 (the standard Elasticsearch port). Take a look at the default config. You can see the Elasticsearch configuration looks something like this:</p> <pre><code>{\n\"esclient\": {\n\"hosts\": [{\n\"host\": \"localhost\",\n\"port\": 9200\n}]\n... // rest of config\n}\n</code></pre> <p>If you want to connect to Elasticsearch somewhere else, change <code>localhost</code> as needed. You can specify multiple hosts if you have a large cluster. In fact, the entire <code>esclient</code> section of the config is sent along to the elasticsearch-js module, so any of its configuration options are valid.</p>"},{"location":"documentation/pelias-from-scratch/#where-to-find-the-downloaded-data-files","title":"Where to find the downloaded data files","text":"<p>The other major section, <code>imports</code>, defines settings for each importer.  <code>adminLookup</code> has it's own section and its value applies to all importers. The defaults look like this:</p> <pre><code>{\n\"imports\": {\n\"adminLookup\": {\n\"enabled\": true\n},\n\"geonames\": {\n\"datapath\": \"/mnt/pelias/geonames\",\n},\n\"openstreetmap\": {\n\"datapath\": \"/mnt/pelias/openstreetmap\",\n\"leveldbpath\": \"/tmp\",\n\"import\": [{\n\"filename\": \"planet.osm.pbf\"\n}]\n},\n\"openaddresses\": {\n\"datapath\": \"/mnt/pelias/openaddresses\",\n\"files\": []\n},\n\"whosonfirst\": {\n\"datapath\": \"/mnt/pelias/whosonfirst\"\n},\n\"polyline\": {\n\"datapath\": \"/mnt/pelias/polyline\",\n\"files\": []\n}\n}\n}\n</code></pre> <p>Note: The datapath must be an absolute path. As you can see, the default datapaths are meant to be changed.</p>"},{"location":"documentation/pelias-from-scratch/#install-elasticsearch","title":"Install Elasticsearch","text":"<p>Please refer to the official Elasticsearch install docs for how to install Elasticsearch.</p> <p>Be sure to modify the Elasticsearch heap size as appropriate to your machine.</p> <p>Make sure Elasticsearch is running and connectable, and then you can continue with the Pelias specific setup and importing. Using a plugin like Sense (Chrome extension), head or Marvel can help monitor Elasticsearch as you import data.</p>"},{"location":"documentation/pelias-from-scratch/#set-up-the-elasticsearch-schema","title":"Set up the Elasticsearch Schema","text":"<p>Pelias requires specific configuration settings for both performance and accuracy reasons. Fortunately, now that your <code>pelias.json</code> file is configured with how to connect to Elasticsearch, the schema repository can automatically create the Pelias index and configure it exactly as needed.</p> <p><pre><code>cd schema                      # assuming you have just run the bash snippet to download the repos from earlier\n./bin/create_index\n</code></pre> The Elasticsearch Schema is analogous to the layout of a table in a traditional relational database, like MySQL or PostgreSQL. While Elasticsearch attempts to auto-detect a schema that works when inserting new data, it doesn't do a great job. Pelias requires specific schema settings or it won't work at all.</p>"},{"location":"documentation/pelias-from-scratch/#run-the-importers","title":"Run the importers","text":"<p>Now that the schema is set up, you're ready to begin importing data.</p> <p>For each importer, you can start the import process with the <code>npm start</code> command:</p> <pre><code>cd importer_directory; npm start\n</code></pre> <p>Depending on how much data you've imported, now may be a good time to grab a coffee. You can expect up to 7000 records per second per importer.</p> <p>The order of imports does not matter. Multiple importers can be run in parallel to speed up the setup process. Each of our importers operates independent of the data that is already in Elasticsearch. For example, you can import OSM data without importing WOF data first.</p>"},{"location":"documentation/pelias-from-scratch/#aside-when-to-delete-the-data-already-in-elasticsearch","title":"Aside: When to delete the data already in Elasticsearch","text":"<p>If you have previously run a build, and are looking to start another one, it generally a good idea to delete the existing Pelias index and re-create it. Here's how:</p> <pre><code># !! WARNING: this will remove all your data from pelias!!\nnode scripts/drop_index.js      # it will ask for confirmation first\n./bin/create_index\n</code></pre> <p>When is this necessary? Here's a guideline: when in doubt, delete the index, re-create it, and start fresh. That's always the safest approach.</p> <p>The only time when restarting importers without deleting is recommended is if all the following conditions are true: 1. You are trying to re-import the exact same data again. For example, because the build failed, or    you are testing changes to an importer. Pelias importers will not create    duplicate records if importing the same data, however, they can't account    for changes in the data itself. 2. The Pelias schema has not changed. Elasticsearch has no concept similar    to a schema migration from a traditional database, so any schema changes    require deleting and re-importing all data. 3. You are not concerned with ensuring maximum performance when performing    queries. Elasticsearch internally does not actually perform updates: it    deletes old versions of a record and creates a new one. So re-writing the    same or similar documents repeatedly can create a larger Elasticsearch index    that has slightly worse performance.</p>"},{"location":"documentation/pelias-from-scratch/#install-and-start-the-pelias-services","title":"Install and start the Pelias Services","text":"<p>Pelias is made up of several different services, each providing specific functionality.</p> <p>The list of Pelias services describes the functionality of each service, and can be used to determine if you need to install that service. It also includes links to setup instructions for each service.</p> <p>When in doubt, install everything except the interpolation engine (it requires a long download and build process).</p>"},{"location":"documentation/pelias-from-scratch/#configure-peliasjson-for-services","title":"Configure <code>pelias.json</code> for services","text":"<p>The Pelias API needs to know about each of the other services available to it. Once again, this is configured in <code>pelias.json</code>. The following section will tell the API to use all services running locally and on their default ports.</p> <pre><code>{\n\"api\": {\n\"services\": {\n\"placeholder\": {\n\"url\": \"http://localhost:3000\"\n},\n\"libpostal\": {\n\"url\": \"http://localhost:8080\"\n},\n\"pip\": {\n\"url\": \"http://localhost:3102\"\n},\n\"interpolation\": {\n\"url\": \"http://localhost:3000\"\n}\n}\n}\n}\n</code></pre>"},{"location":"documentation/pelias-from-scratch/#start-the-api","title":"Start the API","text":"<p>Now that the API knows how to connect to Elasticsearch and all other Pelias services, all that is required to start the API is:</p> <pre><code>npm start\n</code></pre>"},{"location":"documentation/pelias-from-scratch/#geocode-with-pelias","title":"Geocode with Pelias","text":"<p>Pelias should now be up and running and will respond to your queries.</p> <p>For a quick check, a request to <code>http://localhost:3100</code> should display a link to the documentation for handy reference.</p> <p>Here are some queries to try:</p> <p>http://localhost:3100/v1/search?text=london: a search for the city of London.</p> <p>http://localhost:3100/v1/autocomplete?text=londo: another query for London, but using the autocomplete endpoint which supports partial matches and is intended to be sent queries as a user types (note the query is for <code>londo</code> but London is returned)</p> <p>http://localhost:3100/v1/reverse?point.lon=-73.986027&amp;point.lat=40.748517: a reverse geocode for results near the Empire State Building in New York City.</p> <p>For information on everything Pelias can do, see our documentation index.</p> <p>Happy geocoding!</p>"},{"location":"documentation/place/","title":"<code>/v1/place</code> endpoint for details","text":"<p>When you know an identification number and the source it came from, you can use Pelias to get details on the location.</p> <p>For now, the <code>/place</code> endpoint returns exactly the same data that any other would. However, in the future, we plan to allow more information, perhaps geometries to be returned here.</p> <p>The <code>/place</code> endpoint accepts Pelias <code>gid</code> strings that get returned for every exactly matched record in query responses. These <code>gid</code> strings should not be built manually, but rather used directly as-is to lookup additional details on the location that <code>gid</code> refers to.</p> <p>For example, this <code>/place</code> query looks up the Eiffel Tower in OpenStreetMap (OSM):</p> <p>/v1/place?ids=openstreetmap:venue:way/5013364</p> <p>Note that you need an actual <code>gid</code> value to make a <code>/place</code> search. For example, if you search for an address and the result is interpolated, then there is no discrete <code>gid</code> to use for a <code>/place</code> search because interpolated results may be from multiple data sources.</p>"},{"location":"documentation/place/#search-for-multiple-places-in-a-query","title":"Search for multiple places in a query","text":"<p>To search for more than one <code>/place</code> in a request, join multiple values together and separate them with a comma. For example, this <code>/place</code> query looks up the Eiffel Tower in OpenStreetMap and the borough of Manhattan in Who's on First:</p> <p>/v1/place?ids=openstreetmap:venue:way/5013364,whosonfirst:borough:421205771</p> <p>The results are returned in the order requested.</p>"},{"location":"documentation/place/#return-categories-in-responses","title":"Return categories in responses","text":"<p>You can get some metadata from places such as categories. Categories let you know how to classify an element. For example the <code>Ch\u00e2teau de Versailles</code> (<code>Palace of Versailles</code>) in OpenStreetMap is classified as <code>entertainment</code>.</p> <p>/v1/place?categories&amp;ids=openstreetmap:venue:relation/1149002</p>"},{"location":"documentation/place/#error-handling","title":"Error handling","text":"<p>If you enter a valid <code>gid</code> that cannot be found or has \"expired\" due to a newer build, you may get empty results. The request will NOT return an error.</p> <p>If the structure of your <code>gid</code> is invalid, an error will be returned as part of the GeoJSON structure.</p> <p>Keep in mind that if you enter a <code>gid</code> that cannot be found in a list of multiple IDs, then the <code>features</code> array in the response contains a different number of elements than the number of requests. For example, your request may have three IDs requested but only two results returned. The reason for this is that the <code>features</code> section of the response is GeoJSON-compliant, and JSON does not allow a way to convey an exception condition (not even an empty JSON element, <code>{}</code>). For this reason, if your application is dependent upon the results mapping directly to the individual input requests in order, then you'll have to do your own bookkeeping to handle exception conditions.</p>"},{"location":"documentation/place/#warning-datasets-without-stable-ids","title":":warning: Datasets without stable IDs","text":"<p>Due to the ever-changing nature of most open-datasets used by Pelias, some <code>gids</code> can change merely by importing newer data.</p> <p>Both Geonames and Who's on First have excellent, stable IDs and should not cause trouble. However, OpenAddresses and OpenStreetMap do not have stable IDs. Be careful.</p>"},{"location":"documentation/place/#available-places-parameters","title":"Available places parameters","text":"Parameter Type Required Default Example <code>gid</code> string yes none <code>whosonfirst:borough:421205771</code> <code>categories</code> none no none Check only if the query parameter is present"},{"location":"documentation/requirements/","title":"Pelias Software requirements","text":"<p>This is the list of all software requirements for Pelias. We highly recommend using our Docker images to avoid having to even attempt to correctly install all our dependencies yourself.</p>"},{"location":"documentation/requirements/#nodejs","title":"Node.js","text":"<p>Version 10 or Version 12</p> <p>Version 12 is recommended for best performance.</p> <p>Most Pelias code is written in Node.js, so this is one of the most core dependencies of the project.</p> <p>Pelias generally only adds support for even numbered LTS Node.js versions. However we gladly accept patches and bug reports regarding issues with any Node.js version that has not reached end-of-life.</p> <p>We recommend you always use the latest minor and patch release of whichever major release line you choose.</p> <p>We strive to support any minor or patch version of our supported major release lines of Node.js, but on occasion this may not be possible and we'll offer additional guidance.</p>"},{"location":"documentation/requirements/#elasticsearch","title":"Elasticsearch","text":"<p>Version 6.8+ or 7.5+</p> <p>We recommend the latest in the Elasticsearch 7 release line.</p> <p>The core data storage for Pelias is Elasticsearch, and Elasticsearch makes major breaking changes from release to release, so it's important to track these versions carefully.</p>"},{"location":"documentation/requirements/#sqlite","title":"SQLite","text":"<p>Version 3.11 or newer</p> <p>Some components of Pelias need a relational database, and Elasticsearch does not provide good relational support. We use SQLite in these cases since it's simple to manage and quite performant.</p>"},{"location":"documentation/requirements/#libpostal","title":"Libpostal","text":"<p>Pelias relies heavily on the Libpostal address parser. Libpostal requires about 4GB of disk space to download all the required data.</p>"},{"location":"documentation/requirements/#windows-support","title":"Windows Support","text":"<p>Pelias is not well tested on Windows, but we do wish to support it, and will accept patches to fix any issues with Windows support.</p>"},{"location":"documentation/response/","title":"Search Response","text":"<p>When requesting results from Pelias, you will always get back GeoJSON results, unless something goes terribly wrong, in which case you'll get an error message.</p> <p>Tip: You can go to https://tools.ietf.org/html/rfc7946 to learn more about the GeoJSON data format specification.</p> <p>The top-level structure to every response looks like this:</p> <pre><code>{\n  \"geocoding\":{...},\n  \"type\":\"FeatureCollection\",\n  \"features\":[...],\n  \"bbox\":[...]\n}\n</code></pre>"},{"location":"documentation/response/#list-of-features-returned","title":"List of features returned","text":"<p>The <code>features</code> property of the result is where you will find the list of results that best matched your input parameters.</p> <p>Each item in this list will contain all the information needed to find it in human-readable format in the <code>properties</code> block, as well as computer friendly coordinates in the <code>geometry</code> property.</p> <pre><code>{\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -0.125422,\n          51.501581\n        ]\n      },\n      \"properties\": {\n        \"id\": \"101750367\",\n        \"gid\": \"whosonfirst:locality:101750367\",\n        \"layer\": \"locality\",\n        \"source\": \"whosonfirst\",\n        \"souce_id\": \"101750367\",\n        \"name\": \"London\",\n        \"confidence\": 0.949,\n        \"country\": \"United Kingdom\",\n        \"country_gid\": \"whosonfirst:country:85633159\",\n        \"country_a\": \"GBR\",\n        \"macroregion\": \"England\",\n        \"macroregion_gid\": \"whosonfirst:macroregion:404227469\",\n        \"region\": \"City of Westminster\",\n        \"region_gid\": \"whosonfirst:region:85684061\",\n        \"locality\": \"London\",\n        \"locality_gid\": \"whosonfirst:locality:101750367\",\n        \"label\": \"London, England, United Kingdom\"\n      },\n      \"bbox\": [\n        -0.4984345,\n        51.297207,\n        0.27894,\n        51.6843015\n      ]\n    },\n</code></pre> <p>Additionally, /reverse queries will have a <code>distance</code> parameter, which is the distance, in kilometers, from the query point.</p>"},{"location":"documentation/response/#notable-features","title":"Notable features","text":""},{"location":"documentation/response/#coordinates","title":"<code>coordinates</code>","text":"<p>All results returned from Pelias are points, and can be found in the <code>coordinates</code> array. Following the GeoJSON specification, these coordinates are in longitude, latitude order.</p>"},{"location":"documentation/response/#gid","title":"<code>gid</code>","text":"<p>All places in Pelias have a global identifier, known as a <code>gid</code>. Each matching record returned from a /search, /autocomplete, or /reverse geocoding request has a <code>gid</code> field.</p> <p>The <code>gid</code> consists of an identifier for the original data source (such as <code>openstreetmap</code> or <code>openaddresses</code>),  a <code>layer</code> (such as <code>address</code> or <code>country</code>), and an <code>id</code> for the individual record corresponding to the original source identifier, where possible. This information is also available as properties on the individual results as <code>layer</code>, <code>source</code>, and <code>source_id</code>.</p> <p>While useful for identifying a specific record at a particular time, <code>gid</code>s can not always be relied upon to be valid over the course of days, months, or years, as many data sources do not have stable IDs.</p>"},{"location":"documentation/response/#warning-follow-these-guidelines-regarding-the-gid","title":":warning: Follow these guidelines regarding the <code>gid</code>:","text":"<ul> <li>You should not create your own <code>gid</code> strings.</li> <li><code>gid</code> strings may not be consistent across releases.</li> <li>You should not attempt to parse <code>gid</code> strings for information or store them for future use. You should only use <code>gid</code> at the time when you receive the search results. One valid use for the <code>gid</code> is to retrieve full details on a particular result from the /place endpoint.</li> </ul>"},{"location":"documentation/response/#name","title":"<code>name</code>","text":"<p>The <code>name</code> is a short description of the location, such as a business name, a locality name, or part of an address, depending on what is being searched for and what is returned.</p> <p>For address searches, the <code>housenumber</code> and <code>street</code> properties are brought together under the <code>name</code> property in the local standard format. This saves you from having to reassemble the address yourself, including to determine whether the numbers should be placed before or after the street name.</p>"},{"location":"documentation/response/#label","title":"<code>label</code>","text":"<p>The <code>label</code> is a human-friendly representation of the place, with the most complete details, that is ready to be displayed to an end user. Examples of a <code>label</code> include a business or venue name with its locality, a complete mailing address, or a locality with region and country names. The <code>label</code> field attempts to use a format that is right for the region of the result.</p>"},{"location":"documentation/response/#confidence","title":"<code>confidence</code>","text":"<p>The confidence score is an estimation of how accurately this result matches the query.</p> <p>For the /reverse endpoint, the confidence score is determined solely by its distance from the coordinate specified. Closer results get a higher score.</p> <p>For the /search endpoint, it primarily takes into account how well properties in the result match what was expected from parsing the input text. For example, if the input text looks like an address, but the house number of the result doesn't match the house number that was parsed from the input text, the confidence score will be lower.</p> <p>Additionally, the confidence score can optionally be biased along with other results, like test scores in a classroom might be graded on a curve. This takes into account both the property matches described above and the distance between results. This relative scoring is enabled on Pelias, but can be turned off when hosting your own Pelias instance.</p>"},{"location":"documentation/response/#bbox","title":"<code>bbox</code>","text":"<p>Features from Who's on First and OpenStreetMap often have their own <code>bbox</code> elements. This <code>bbox</code> is at the same level as <code>properties</code>. If present, it describes the geographic extent of the feature, such as the screen size necessary to show all of California without needing to send the precise polygon geometry. This should be treated as separate from the <code>bbox</code> that describes the entire <code>FeatureCollection</code>.</p>"},{"location":"documentation/response/#result-count","title":"Result count","text":"<p>By default, Pelias results 10 places, unless otherwise specified. If you want a different number of results, set the <code>size</code> parameter to the desired number. This example shows returning only the first result.</p> parameter value <code>text</code> YMCA <code>size</code> 1 <p>/v1/search?size=1</p> <p>If you want 25 results, you can build the query where <code>size</code> is 25.</p> <p>/v1/search?size=25</p>"},{"location":"documentation/result-quality/","title":"Determining Result Quality","text":"<p>Each result returned from Pelias contains several different properties to help you programmatically determine if a result is good enough for your purposes.</p>"},{"location":"documentation/result-quality/#match_type","title":"match_type","text":"<p>This field is present on queries to the search and structured search endpoints only.</p> <p>There are three possible values: <code>exact</code>, <code>interpolated</code>, and <code>fallback</code>.</p> <p>If Pelias found exactly what it believes you were looking for, the <code>match_type</code> value will be <code>exact</code>.</p> <p>If Pelias determined you are querying for a street address, and could not find that exact address, but was able to estimate where that address might be (if it exists) via the interpolation engine, the match type will be <code>interpolated</code>.</p> <p>If Pelias wasn't able to return exactly what it thinks you asked for, it will try to return something that relates to your query in an intelligent way. These fallback results will be records that follow the relationships of places in the real world.</p>"},{"location":"documentation/result-quality/#some-examples","title":"Some examples:","text":"<p>A query for 1600 Pennsylvania Avenue, Seattle, Washington returns the city of Seattle, since there is no Pennsylvania Avenue in Seattle. In previous versions of Pelias, this query would return 1600 Pennsylvania Avenue addresses in other parts of the world (such as the famous White House address in Washington, D.C.).</p> <p>A query for France will return one result, with <code>match_type</code> <code>exact</code>. However, a query for the non-existent city of Berlin, France will also return France, but in this case with a match type of <code>fallback</code>. Pelias knows you were looking for something in the country of France called Berlin. It couldn't find it, so instead of returning one of the many other Berlins, it returns France. This demonstrates that the <code>match_type</code> value depends on the query and the result.</p>"},{"location":"documentation/result-quality/#confidence","title":"confidence","text":"<p>This is a general score computed to calculate how likely result is what was asked for. It's meant to be a combination of all the information available to Pelias. It's not super sophisticated, and results may not be sorted in confidence-score order. In that case results returned first should be trusted more. Confidence scores are floating point numbers ranging from <code>0.0</code> to <code>1.0</code>.</p> <p>Confidence scores are calculated differently for different endpoints:</p> <p>For reverse geocoding it's based on distance from the reverse geocoded point. The progression of confidence scores is as follows:</p> distance confidence score &lt; 1 meter 1.0 1 - 10 meters 0.9 11 - 100 meters 0.8 101 - 250 meters 0.7 251 - 1000 meters 0.6 <p>For forward geocoding and autocomplete, several factors affect the score. These factors are:</p> <ul> <li>the <code>match_type</code>, as described above</li> <li>whether the postal code matched (postal codes must be an optional part of all Pelias queries since not all records have known postal codes)</li> <li>for address results, whether the housenumber and street name match the input query</li> <li>whether any other fields are obviously non-matching (such as the city, region, or country fields).</li> </ul> <p>In all cases, confidence scores for <code>fallback</code> results will be reduced.</p>"},{"location":"documentation/result-quality/#layer","title":"layer","text":"<p>This is essentially what type of result was returned, for example whether the result was an address, a city, or a country (a full list of possible layers can be found in the search endpoint documentation).</p> <p>The <code>layers</code> parameter can be used to filter out undesired results if you know ahead of time what you want.</p> <p>Results that have a <code>layer</code> value that you did not expect generally represent a fallback scenario, and should be checked carefully.</p>"},{"location":"documentation/result-quality/#accuracy","title":"accuracy","text":"<p>The accuracy field gives information on the accuracy of the latitude/longitude point returned with the given result. This value is a property of the result itself and won't change based on the query. There are currently two possible values for the <code>accuracy</code> field: <code>point</code> and <code>centroid</code>.</p> <p><code>point</code> results are generally addresses, venues, or interpolated addresses. A point result means the record represents a record that can reasonably be represented by a single latitude/longitude point.</p> <p><code>centroid</code> results, on the other hand, are records that represent a larger area, such as a city or country. Pelias cannot currently return results with geometries made of polygons or lines, so all such records are estimated with a centroid.</p> <p>In the future, Pelias will likely add support for proper complex geometries.</p>"},{"location":"documentation/reverse/","title":"Reverse geocoding","text":"<p>Reverse geocoding is used for finding places or addresses near a latitude, longitude pair\u2014like clicking on a map to see what's there when the map doesn't show it otherwise. For example, picture a map showing building outlines but no labels, then clicking on a building and being shown the name of the business. That's reverse geocoding.</p> <p>With reverse geocoding with Pelias, you can look up all sorts of information about points on a map, including:</p> <ul> <li>addresses</li> <li>points of interest (businesses, museums, parks, and so on)</li> <li>neighborhoods</li> <li>cities</li> <li>states</li> <li>postal areas</li> <li>countries</li> </ul> <p>To get started with reverse geocoding, you need a latitude, longitude pair in decimal degrees specified with the parameters <code>point.lat</code> and <code>point.lon</code>, respectively.  For example, the Eiffel Tower in Paris, France, is located at <code>48.858268,2.294471</code>. The reverse geocode query for this would be:</p> <p>/v1/reverse?point.lat=48.858268&amp;point.lon=2.294471</p> <p>The output is the standard GeoJSON format.</p>"},{"location":"documentation/reverse/#reverse-geocoding-parameters","title":"Reverse geocoding parameters","text":"<p>Like other queries with Pelias, reverse geocoding has optional, additional parameters you can use to refine results.</p> Parameter Type Required Default Example <code>point.lat</code> floating point number yes none <code>48.858268</code> <code>point.lon</code> floating point number yes none <code>2.294471</code> <code>boundary.circle.radius</code> floating point number no 1 <code>35</code> <code>size</code> integer no <code>10</code> <code>3</code> <code>layers</code> comma-delimited string array no none (all layers) <code>address,locality</code> <code>sources</code> comma-delimited string array no none (all sources) <code>oa,gn</code> <code>boundary.country</code> comma separated list of ISO-3166 alpha-2 or alpha-3 no none <code>FR,GBR</code> <code>boundary.gid</code> Pelias <code>gid</code> no none <code>whosonfirst:locality:101748355</code>"},{"location":"documentation/reverse/#size","title":"Size","text":"<p>A basic parameter for filtering is <code>size</code>, which is used to limit the number of results returned. In the earlier request that returned the Eiffel Tower (or 'Tour Eiffel', to be exact), notice that other results were returned including \"Bureau de Gustave Eiffel\" (a museum) and \"Le Jules Verne\" (a restaurant). To limit a reverse geocode to only the first result, pass the <code>size</code> parameter:</p> <p>/v1/reverse?point.lat=48.858268&amp;point.lon=2.294471&amp;size=1</p> <p>The default value for <code>size</code> is <code>10</code> and the maximum value is <code>40</code>. Specifying a value greater than <code>40</code> will override to <code>40</code> and return a warning in the response metadata.</p>"},{"location":"documentation/reverse/#filter-by-data-source","title":"Filter by data source","text":"<p>By default, reverse geocoding returns results from any data source available to Pelias. To filter results by source, specify one or more valid source names in a comma-delimited list using the <code>sources</code> parameter. For example, the following request returns only results from OpenStreetMap:</p> source name short name OpenStreetMap <code>openstreetmap</code> <code>osm</code> OpenAddresses <code>openaddresses</code> <code>oa</code> Who's on First <code>whosonfirst</code> <code>wof</code> GeoNames <code>geonames</code> <code>gn</code> <p>/v1/reverse?point.lat=48.858268&amp;point.lon=2.294471&amp;sources=osm</p>"},{"location":"documentation/reverse/#filter-by-layers-data-type","title":"Filter by layers (data type)","text":"<p>Without specifying further, reverse geocoding doesn't restrict results to a particular type (street, venue, neighbourhood, and so on).  If your application is only concerned with, say, which city a latitude, longitude is closest to, then use the <code>layers</code> parameter.  For example, the following request returns only results that are localities (cities and towns):</p> <p>/v1/reverse?point.lat=48.858268&amp;point.lon=2.294471&amp;layers=locality</p> <p>Here are all the supported layers and their meanings.</p> layer description <code>venue</code> points of interest, businesses, things with walls <code>address</code> places with a street address <code>street</code> streets,roads,highways <code>country</code> places that issue passports, nations, nation-states <code>macroregion</code> a related group of regions. Mostly in Europe <code>region</code> states and provinces <code>macrocounty</code> a related group of counties. Mostly in Europe. <code>county</code> official governmental area; usually bigger than a locality, almost always smaller than a region <code>locality</code> towns, hamlets, cities <code>localadmin</code> local administrative boundaries <code>borough</code> a local administrative boundary, currently only used for New York City <code>neighbourhood</code> social communities, neighbourhoods <code>coarse</code> alias for simultaneously using all administrative layers (everything except <code>venue</code> and <code>address</code>)"},{"location":"documentation/reverse/#filter-by-country","title":"Filter by country","text":"<p>If you are performing a reverse geocode near a country boundary, and are only interested in results from one country and not the other, you can specify a country code. You can set the <code>boundary.country</code> parameter value to the alpha-2 or alpha-3 ISO-3166 country code. For example, the latitude,longitude pair <code>47.270521,9.530846</code> is on the boundary of Austria, Liechtenstein, and Switzerland. Without specifying a <code>boundary.country</code>, the first 10 results returned may come from all three countries. By including <code>boundary.country=LIE</code>, all 10 results will be from Liechtenstein. Here's the request in action:</p> <p>/v1/reverse?point.lat=47.270521&amp;point.lon=9.530846&amp;boundary.country=LIE</p> <p>Note that <code>UK</code> is not a valid ISO 3166-1 alpha-2 country code.</p>"},{"location":"documentation/reverse/#distance-and-confidence-scores-for-the-results","title":"Distance and confidence scores for the results","text":"<p>Each result returned has a distance from the query point (in kilometers) and an associated confidence score. Confidence scores are calculated based on the distance from the result to the supplied <code>point.lat</code> and <code>point.lon</code>. Confidence scoring for reverse geocode results is likely to change with different data sources and layers.</p> Distance from <code>point.lat</code>/<code>point.lon</code> Confidence score &lt; 1m 1.0 &lt; 10m 0.9 &lt; 100m 0.8 &lt; 250m 0.7 &lt; 1km 0.6 &gt;= 1km 0.5"},{"location":"documentation/reverse/#example-requests","title":"Example requests","text":"<p>This section shows how the various parameters can be combined to form complex use cases.</p>"},{"location":"documentation/reverse/#all-results-near-the-tower-of-london","title":"All results near the Tower of London","text":"<p>/v1/reverse?point.lat=51.5081124&amp;point.lon=-0.0759493</p>"},{"location":"documentation/reverse/#only-openstreetmap-results-near-the-tower-of-london","title":"Only OpenStreetMap results near the Tower of London","text":"<p>/v1/reverse?point.lat=51.5081124&amp;point.lon=-0.0759493&amp;sources=osm</p>"},{"location":"documentation/reverse/#only-street-addresses-near-the-tower-of-london","title":"Only street addresses near the Tower of London","text":"<p>/v1/reverse?point.lat=51.5081124&amp;point.lon=-0.0759493&amp;layers=address</p>"},{"location":"documentation/reverse/#only-openstreetmap-street-addresses-near-the-tower-of-london","title":"Only OpenStreetMap street addresses near the Tower of London","text":"<p>/v1/reverse?point.lat=51.5081124&amp;point.lon=-0.0759493&amp;layers=address&amp;sources=osm</p>"},{"location":"documentation/reverse/#only-the-first-openstreetmap-address-near-the-tower-of-london","title":"Only the first OpenStreetMap address near the Tower of London","text":"<p>/v1/reverse?point.lat=51.5081124&amp;point.lon=-0.0759493&amp;layers=address&amp;sources=osm&amp;size=1</p>"},{"location":"documentation/search-workflows/","title":"Common geocoding workflows","text":"<p>Pelias provides several API endpoints, and each is best suited for a particular geocoding workflow. Match your use case to these common scenarios to determine which endpoint to use for tasks in your app.</p>"},{"location":"documentation/search-workflows/#you-have-a-single-address-field-that-needs-geographic-coordinates-search","title":"You have a single address field that needs geographic coordinates (<code>/search</code>)","text":"<p>In this scenario, your data might have customer records, for example, with a single field provided for the address information. The address field might also have a variety of data in it, and is not guaranteed to be formatted in any specific way.</p> id name address occupation 321 Jane Banks 17 Cherry Tree Lane, London student 654 Paddington Bear 32 Windsor Gardens, London bear 987 Sherlock Holmes 221B Baker St, London private investigator <p>If your data is free-form like those entries, try forward search with the <code>/search</code> endpoint. It requires a single <code>text</code> input to be specified, which is set to the individual string for each of your records.</p>"},{"location":"documentation/search-workflows/#you-have-an-address-split-into-its-constituent-parts-searchstructured","title":"You have an address split into its constituent parts (<code>/search/structured</code>)","text":"<p>You might have data that is broken up into columns, where each column represents a part of the address.</p> id name address city country occupation 321 Jane Banks 17 Cherry Tree Lane London GBR student 654 Paddington Bear 32 Windsor Gardens London GBR bear 987 Sherlock Holmes 221B Baker St London GBR private investigator <p>You should use structured geocoding (<code>/search/structured</code>) for this scenario. If you already know which part of the address corresponds to which field, there is no need to concatenate them all together only to need to break them up again to search. This will help avoid potential errors in both the concatenation and the parsing processes.</p> <p>Your columns might vary depending on your database design or input forms used to collect the data, so it is okay if your columns have different names as the ones in this example. Structured geocoding supports a variety of address parts so you can map your columns to each part as needed.</p> <p>Tip: Use filters if you know more information about your data or want to limit the search in some way. You can filter by country, rectangle, or circle. So, for example, notice all the data in the example is in <code>GBR</code>. The more specific you can be in your search requests, the less likely you are to receive an unexpected result.</p>"},{"location":"documentation/search-workflows/#you-have-latitude-and-longitude-data-and-want-the-corresponding-address-reverse","title":"You have latitude and longitude data and want the corresponding address (<code>/reverse</code>)","text":"<p>When you use a mapping app, it is common to click a location to find out the address there. Similarly, when you use your phone to request assistance from the police, for example, your location is often automatically translated to an address where the officers can be routed. In these cases, reverse geocoding is happening behind the scenes.</p> <p>You use the <code>/reverse</code> endpoint when you know the coordinates of your location, and want to learn the address or information about nearest point of interest, such as the name of a business, restaurant, or park.</p>"},{"location":"documentation/search-workflows/#you-have-latitude-and-longitude-data-and-want-the-administrative-area-it-falls-within-reverse-with-layers","title":"You have latitude and longitude data and want the administrative area it falls within (<code>/reverse</code> with <code>layers</code>)","text":"<p>Sometimes, when you click on a map, you want information about the region containing that location. This is a variation of a reverse search, known as coarse reverse geocoding, where you can look up administrative hierarchy information for a given set of coordinates. This can be very useful when you have linked the administrative boundary with other datasets--for example, allowing you to click a house to find out its local government representative or which fire department serves it.</p> <p>For coarse reverse, use the <code>/reverse</code> endpoint and <code>layers=coarse</code> or include any of the administrative area types, such as <code>locality</code>, <code>region</code>, or <code>country</code>. If you only want the administrative information, using coarse reverse can improve performance because there are far fewer administrative regions globally than there are individual addresses to query.</p>"},{"location":"documentation/search-workflows/#you-have-users-typing-into-a-search-box-or-address-input-field-in-real-time-autocomplete-or-search","title":"You have users typing into a search box or address input field in real time (<code>/autocomplete</code> or <code>/search</code>)","text":"<p>When you have live users who type things into input fields or search boxes, their activity falls into two scenarios, depending on when your app assumes they are ready to search.</p> <p>The distinction in the results is visible when you consider the behavior with the text of <code>lond</code>. Autocomplete for <code>lond</code>, returns <code>london</code> because the user is still typing, but <code>/search</code> assumes the user is done entering text and returns the city of <code>Lond</code> in Pakistan.</p>"},{"location":"documentation/search-workflows/#and-want-to-show-feedback-as-they-type-autocomplete","title":"...and want to show feedback as they type (<code>/autocomplete</code>)","text":"<p>When you are searching for a hotel in a particular city, for example, you often see a list of matching results appear after each character as you type. In your own app, if you want your users to enter text and see real-time results as they type, use <code>/autocomplete</code>. This type-ahead functionality helps users find what they are looking for, without requiring them to fully specify their search term. Typically, your users start typing and a drop-down list appears where they can choose the term from the list.</p>"},{"location":"documentation/search-workflows/#and-want-to-search-only-when-they-finish-typing-search","title":"...and want to search only when they finish typing (<code>/search</code>)","text":"<p>If you want the search to occur only when specifically executed, such as when your users press Enter, use <code>/search</code>. A search operates under the assumption that the input text is complete. A common design pattern is for an app to use autocomplete for the initial type-ahead behavior, and then switch to a <code>/search</code> when the user presses Enter or clicks an entry from the list.</p> <p>The <code>/search</code> endpoint offers some functionality that is not currently available for <code>/autocomplete</code>. This includes structured searching and address interpolation for locations where data is incomplete.</p>"},{"location":"documentation/search/","title":"Pelias: Finding places","text":"<p>Geocoding is the process of matching an address or other text to its corresponding geographic coordinates.</p> <p>All Pelias requests share the same format:</p> <pre><code>   https://search.mapzen.com/v1/search?text=London\n   \\___/   \\_______________/\\__/\\_____/\\_________/\n     |            |          /     |        |\n  scheme       domain   version  path     query\n</code></pre>"},{"location":"documentation/search/#search-the-world","title":"Search the world","text":"<p>In the simplest search, you can provide only one parameter, the text you want to match in any part of the location details. To do this, build a query where the <code>text</code> parameter is set to the item you want to find.</p> <p>For example, if you want to find a YMCA facility, here's what you'd need to append to the base URL of the service.</p> <p>/v1/search?text=YMCA</p> <p>Note the parameter values are set as follows:</p> parameter value <code>text</code> YMCA <p>Clicking the link above will open a file containing the best matching results for the text <code>YMCA</code>. You will notice the data is in a computer-friendly format called GeoJSON, which may be hard for humans to read in some browsers.</p> <p>You can install a plug-in for your browser to display JSON in a more formatted manner. You can search the web store for your browser to find and install applicable products.</p> <p>In the example above, you will find the name of each matched locations in a property named <code>'label'</code>. The top 10 labels returned at the time of writing were:</p> <ul> <li>YMCA, Bargoed Community, United Kingdom</li> <li>YMCA, Nunspeet, Gelderland</li> <li>YMCA, Belleville, IL</li> <li>YMCA, Forest City, IA</li> <li>YMCA, Fargo, ND</li> <li>YMCA, Taipei, Taipei City</li> <li>YMCA, Orpington, Greater London</li> <li>YMCA, Frisco, TX</li> <li>YMCA, Jefferson, OH</li> <li>YMCA, Belleville, IL</li> </ul> <p>Spelling matters, but not capitalization when performing a query with Pelias. You can type <code>ymca</code>, <code>YMCA</code>, or even <code>yMcA</code>. See for yourself by comparing the results of the earlier search to the following:</p> <p>/v1/search?text=yMcA</p> <p>Note that the results are spread out throughout the world because you have not given your current location or provided any other geographic context in which to search.</p>"},{"location":"documentation/search/#set-the-number-of-results-returned","title":"Set the number of results returned","text":"<p>By default, Pelias returns up to 10 results. If you want a different number, set the <code>size</code> parameter to the desired number. This example shows returning only the first result.</p> parameter value <code>text</code> YMCA <code>size</code> 1 <p>/v1/search?text=YMCA&amp;size=1</p> <p>If you want 25 results, you can build the query where <code>size</code> is 25.</p> <p>/v1/search?text=YMCA&amp;size=25</p>"},{"location":"documentation/search/#narrow-your-search","title":"Narrow your search","text":"<p>If you are looking for places in a particular region, or country, or only want to look in the immediate vicinity of a user with a known location, you can narrow your search to an area. There are different ways of including a region in your query. Pelias supports three types: country, rectangle, and circle.</p>"},{"location":"documentation/search/#search-within-a-particular-country","title":"Search within a particular country","text":"<p>Sometimes your work might require that all the search results be from a particular country or a list of countries. To do this, you can set the <code>boundary.country</code> parameter value to a comma separated list of alpha-2 or alpha-3 ISO-3166 country code.</p> <p>Now, you want to search for YMCA again, but this time only in Great Britain. To do this, you will need to know that the alpha-3 code for Great Britain is GBR and set the parameters like this:</p> <p>/v1/search?text=YMCA&amp;boundary.country=GBR</p> parameter value <code>text</code> YMCA <code>boundary.country</code> GBR <p>Note that all the results are within Great Britain:</p> <ul> <li>YMCA, Bargoed Community, United Kingdom</li> <li>YMCA, Orpington, Greater London</li> <li>YMCA, Erdington, West Midlands</li> <li>YMCA, Malvern CP, United Kingdom</li> <li>YMCA, Ancoats, Greater Manchester</li> <li>YMCA, Carmarthen Community, United Kingdom</li> <li>YMCA, Halebank, Cheshire</li> <li>YMCA, Brightlingsea CP, United Kingdom</li> <li>YMCA, Lenton Abbey, Nottinghamshire</li> <li>YMCA, Old Clee, Lincolnshire</li> </ul> <p>If you try the same search request with different country codes, the results change to show YMCA locations within this region.</p> <p>/v1/search?text=YMCA&amp;boundary.country=USA</p> <p>Results in the United States:</p> <ul> <li>YMCA, Belleville, IL</li> <li>YMCA, Forest City, IA</li> <li>YMCA, Fargo, ND</li> <li>YMCA, Frisco, TX</li> <li>YMCA, Jefferson, OH</li> <li>YMCA, Belleville, IL</li> <li>YMCA, Chapel Hill, NC</li> <li>YMCA, West Lampeter, PA</li> <li>YMCA, Bremerton, WA</li> <li>YMCA, Westerly, RI</li> </ul>"},{"location":"documentation/search/#search-within-a-rectangular-region","title":"Search within a rectangular region","text":"<p>To specify the boundary using a rectangle, you need latitude, longitude coordinates for two diagonals of the bounding box (the minimum and the maximum latitude, longitude).</p> <p>For example, to find a YMCA within the state of Texas, you can set the <code>boundary.rect.*</code> parameter to values representing the bounding box around Texas: min_lon=-106.65 min_lat=25.84 max_lon=-93.51 max_lat=36.5</p> <p>Tip: You can look up a bounding box for a known region with this web tool.</p> <p>/v1/search?text=YMCA&amp;boundary.rect.min_lat=25.84&amp;boundary.rect.min_lon=-106.65&amp;boundary.rect.max_lat=36.5&amp;boundary.rect.max_lon=-93.51</p> parameter value <code>text</code> YMCA <code>boundary.rect.min_lat</code> 25.84 <code>boundary.rect.min_lon</code> -106.65 <code>boundary.rect.max_lat</code> 36.5 <code>boundary.rect.max_lon</code> -93.51 <ul> <li>YMCA, Austin, TX</li> <li>YMCA, Frisco, TX</li> <li>Y.M.C.A, Fort Worth, TX</li> <li>YMCA, Rockwall, TX</li> <li>YMCA, Missouri City, TX</li> <li>YMCA, Northshore, TX</li> <li>YMCA, Austin, TX</li> <li>YMCA, Tulsa, OK</li> <li>YMCA, Los Alamos, NM</li> <li>YMCA, Tulsa, OK</li> </ul>"},{"location":"documentation/search/#search-within-a-circular-region","title":"Search within a circular region","text":"<p>Sometimes you don't have a rectangle to work with, but rather you have a point on earth\u2014for example, your location coordinates\u2014and a maximum distance within which acceptable results can be located.</p> <p>In this example, you want to find all YMCA locations within a 35-kilometer radius of a location in Ontario, Canada. This time, you can use the <code>boundary.circle.*</code> parameter group, where <code>boundary.circle.lat</code> and <code>boundary.circle.lon</code> is your location in Ontario and <code>boundary.circle.radius</code> is the acceptable distance from that location. Note that the <code>boundary.circle.radius</code> parameter is always specified in kilometers.</p> <p>/v1/search?text=YMCA&amp;boundary.circle.lon=-79.186484&amp;boundary.circle.lat=43.818156&amp;boundary.circle.radius=35</p> parameter value <code>text</code> YMCA <code>boundary.circle.lat</code> 43.818156 <code>boundary.circle.lon</code> -79.186484 <code>boundary.circle.radius</code> 35 <p>You can see the results have fewer than the standard 10 items because there are not that many YMCA locations in the specified radius:</p> <ul> <li>YMCA, Toronto, Ontario</li> <li>YMCA, Markham, Ontario</li> <li>YMCA, Toronto, Ontario</li> <li>Metro Central YMCA, Toronto, Ontario</li> <li>Pinnacle Jr YMCA, Toronto, Ontario</li> <li>Cooper Koo Family Cherry Street YMCA Centre, Toronto, Ontario</li> </ul>"},{"location":"documentation/search/#search-within-a-parent-administrative-area","title":"Search within a parent administrative area","text":"<p>Pelias has a powerful understanding of relationships between places. In particular, it has a concept called the administrative hierarchy: each record in Pelias is listed as belonging to a parent neighbourhood, city, region, country, and other regions. This has many uses, including filtering. The Pelias global id (<code>gid</code>) of any record can be used with the <code>boundary.gid</code> filter to return only records with a given parent.</p> <p>For example, finding YMCAs in Oklahoma with only a bounding box would be challenging: the bounding box would include much of nearby Texas, possibly leading to incorrect results.</p> <p>With <code>boundary.gid</code>, this query can return accurate results.</p> <p>/v1/search?text=YMCA&amp;boundary.gid=whosonfirst:region:85688585</p> <ul> <li>YMCA, Stillwater, OK, USA</li> <li>YMCA, Edmond, OK, USA</li> <li>YMCA, Guymon, OK, USA</li> <li>YMCA, Grove, OK, USA</li> <li>YMCA, Midwest City, OK, USA</li> <li>YMCA, Shawnee, OK, USA</li> <li>YMCA, Owasso, OK, USA</li> <li>YMCA, Tulsa, OK, USA</li> <li>YMCA, The Village, OK, USA</li> <li>YMCA, Broken Arrow, OK, USA</li> </ul> <p>In the query above, <code>whosonfirst:region:85688585</code>, is the Pelias <code>gid</code> for Oklahoma, USA. Currently, all parent records come from the Who's on First project. <code>gid</code>s for records can be found using either the Who's on First Spelunker, a tool for searching Who's on First data, or from the responses of other Pelias queries. In this case a search for Oklahoma will return the proper <code>gid</code>.</p>"},{"location":"documentation/search/#specify-multiple-boundaries","title":"Specify multiple boundaries","text":"<p>If you're going to try using multiple boundary types in a single search request, be aware that the results will come from the intersection of all the boundaries. So, if you provide regions that don't overlap, you'll be looking at an empty set of results.</p>"},{"location":"documentation/search/#prioritize-results-by-proximity","title":"Prioritize results by proximity","text":"<p>Many use cases call for the ability to promote nearby results to the top of the list, while still allowing important matches from farther away to be visible. Pelias allows you to prioritize results within geographic boundaries, including around a point, within a country, or within a region.</p>"},{"location":"documentation/search/#prioritize-around-a-point","title":"Prioritize around a point","text":"<p>By specifying a <code>focus.point</code>, results will be sorted in part by their proximity to the given coordinate. All else being equal, results closest to the point will show up higher. However, unlike a <code>boundary.circle</code> query, important results far from the given coordinate may still be returned. This allows, for example, a query for places called Paris with a <code>focus.point</code> value in Texas to return both Paris, TX and Paris, France.</p> <p>To find YMCAs again, but this time near a specific coordinate location (representing the Sydney Opera House) in Sydney, Australia, use <code>focus.point</code>.</p> <p>/v1/search?text=YMCA&amp;focus.point.lat=-33.856680&amp;focus.point.lon=151.215281</p> parameter value <code>text</code> YMCA <code>focus.point.lat</code> -33.856680 <code>focus.point.lon</code> 151.215281 <p>Looking at the results, you can see that the few locations closer to this location show up at the top of the list, sorted by distance. You also still get back a significant amount of remote locations, for a well balanced mix. Because you provided a focus point, Pelias can compute distance from that point for each resulting feature.</p> <ul> <li>YMCA, Redfern, New South Wales [distance: 3.836]</li> <li>YMCA, St Ives (NSW), New South Wales [distance: 14.844]</li> <li>YMCA, Epping (NSW), New South Wales [distance: 16.583]</li> <li>YMCA, Revesby, New South Wales [distance: 21.335]</li> <li>YMCA, Koch\u00e2ang, South Gyeongsang [distance: 8071.436]</li> <li>YMCA, Center, IN [distance: 14882.675]</li> <li>YMCA, Lake Villa, IL [distance: 14847.667]</li> <li>YMCA, Onondaga, NY [distance: 15818.08]</li> <li>YMCA, 's-Gravenhage, Zuid-Holland [distance: 16688.292]</li> <li>YMCA, Loughborough, United Kingdom [distance: 16978.367]</li> </ul>"},{"location":"documentation/search/#combine-boundary-search-and-prioritization","title":"Combine boundary search and prioritization","text":"<p>Now that you have seen how to use boundary and focus to narrow and sort your results, you can examine a few scenarios where they work well together.</p>"},{"location":"documentation/search/#prioritize-within-a-country","title":"Prioritize within a country","text":"<p>Going back to the YMCA search you conducted with a focus around a point in Sydney, the results came back from distant parts of the world, as expected. But say you wanted to only see results from the country in which your focus point lies. You can combine that same focus point in Sydney with the country boundary of Australia like this.</p> <p>/v1/search?text=YMCA&amp;focus.point.lat=-33.856680&amp;focus.point.lon=151.215281</p> parameter value <code>text</code> YMCA <code>focus.point.lat</code> -33.856680 <code>focus.point.lon</code> 151.215281 <code>boundary.country</code> AUS <p>The results below look different from the ones you saw before with only a focus point specified. These results are all from within Australia. You'll note the closest results show up at the top of the list, which is helped by the focus parameter.</p> <ul> <li>YMCA, Redfern, New South Wales [distance: 3.836]</li> <li>YMCA, St Ives (NSW), New South Wales [distance: 14.844]</li> <li>YMCA, Epping (NSW), New South Wales [distance: 16.583]</li> <li>YMCA, Revesby, New South Wales [distance: 21.335]</li> <li>YMCA, Larrakeyah, Northern Territory [distance: 3144.296]</li> <li>YMCA, Kepnock, Queensland [distance: 1001.657]</li> <li>YMCA, Kings Meadows, Tasmania [distance: 917.144]</li> <li>YMCA, Katherine East, Northern Territory [distance: 2873.376]</li> <li>YMCA, Sadadeen, Northern Territory [distance: 2026.731]</li> <li>YMCA, Ararat, Victoria [distance: 841.022]</li> </ul>"},{"location":"documentation/search/#prioritize-within-a-circular-region","title":"Prioritize within a circular region","text":"<p>If you are looking for the nearest YMCA locations, and are willing to travel no farther than 50 kilometers from your current location, you likely would want the results to be sorted by distance from current location to make your selection process easier. You can get this behavior by using <code>focus.point</code> in combination with <code>boundary.circle.*</code>. You can use the <code>focus.point.*</code> values as the <code>boundary.circle.lat</code> and <code>boundary.circle.lon</code>, and add the required <code>boundary.circle.radius</code> value in kilometers.</p> <p>/v1/search?text=YMCA&amp;focus.point.lat=-33.856680&amp;focus.point.lon=151.215281&amp;boundary.circle.lat=-33.856680&amp;boundary.circle.lon=151.215281&amp;boundary.circle.radius=50</p> parameter value <code>text</code> YMCA <code>focus.point.lat</code> -33.856680 <code>focus.point.lon</code> 151.215281 <code>boundary.circle.lat</code> -33.856680 <code>boundary.circle.lon</code> 151.215281 <code>boundary.circle.radius</code> 50 <p>Looking at these results, they are all less than 50 kilometers away from the focus point:</p> <ul> <li>YMCA, Redfern, New South Wales [distance: 3.836]</li> <li>YMCA, St Ives (NSW), New South Wales [distance: 14.844]</li> <li>YMCA, Epping (NSW), New South Wales [distance: 16.583]</li> <li>YMCA, Revesby, New South Wales [distance: 21.335]</li> <li>Caringbah YMCA, Caringbah, New South Wales [distance: 22.543]</li> <li>YMCA building, Loftus, New South Wales [distance: 25.756]</li> </ul>"},{"location":"documentation/search/#filter-your-search","title":"Filter your search","text":"<p>Pelias brings together data from multiple open sources and combines a variety of place types into a single database, allowing you options for selecting the dataset you want to search.</p> <p>With Pelias, you can filter by:</p> <ul> <li><code>sources</code>: the originating source of the data</li> <li><code>layers</code>: the kind of place you want to find</li> </ul>"},{"location":"documentation/search/#filter-by-data-source","title":"Filter by data source","text":"<p>The search examples so far have returned a mix of results from all the data sources available to Pelias. Here are the sources being searched:</p> source name short name OpenStreetMap <code>openstreetmap</code> <code>osm</code> OpenAddresses <code>openaddresses</code> <code>oa</code> Who's on First <code>whosonfirst</code> <code>wof</code> GeoNames <code>geonames</code> <code>gn</code> <p>If you use the <code>sources</code> parameter, you can choose which of these data sources to include in your search. So if you're only interested in finding a YMCA in data from OpenAddresses, for example, you can build a query specifying that data source.</p> <p>/v1/search?text=YMCA&amp;sources=oa</p> parameter value <code>text</code> YMCA <code>sources</code> oa <p>Because OpenAddresses is, as the name suggests, only address data, here's what you can expect to find:</p> <ul> <li>20 Ymca Drive, Niagara, ON, Canada</li> <li>341 Ymca Rd, New Hope, AL, USA</li> <li>318 Ymca Rd, New Hope, AL, USA</li> <li>138 Ymca Rd, New Hope, AL, USA</li> <li>304 Ymca Rd, New Hope, AL, USA</li> <li>1919 Ymca Lane, Minnetonka, MN, USA</li> <li>101 Ymca Dr, Kannapolis, NC, USA</li> <li>2121 Ymca Camp Road, Stokes County, NC, USA</li> <li>1110 Ymca Camp Road, Stokes County, NC, USA</li> <li>1581 Ymca Camp Road, Stokes County, NC, USA</li> </ul> <p>If you wanted to combine several data sources together, set <code>sources</code> to a comma separated list of desired source names. Note that the order of the comma separated values does not impact sorting order of the results; they are still sorted based on the linguistic match quality to <code>text</code> and distance from <code>focus</code>, if you specified one.</p> <p>/v1/search?text=YMCA&amp;sources=osm,gn</p> parameter value <code>text</code> YMCA <code>sources</code> osm,gn <p>Each of the data sources supported by Pelias can have different properties, licenses, and strengths. You can learn more on the data sources for Pelias page.</p>"},{"location":"documentation/search/#filter-by-data-type","title":"Filter by data type","text":"<p>In Pelias, different types of results are given different <code>layer</code> values. This helps us differentiate, for example, an address from a point of interest from a country.</p> <p>The Pelias layers are derived from the hierarchy created by the gazetteer Who's on First and can be used to help you filter for just the types of results you want.</p> <p>Here's a list of the types of places you could find in the results, sorted by granularity:</p> layer description <code>venue</code> points of interest, businesses, things with walls <code>address</code> places with a street address <code>street</code> streets,roads,highways <code>neighbourhood</code> social communities, neighbourhoods <code>borough</code> a local administrative boundary, currently only used for New York City <code>localadmin</code> local administrative boundaries <code>locality</code> towns, hamlets, cities <code>county</code> official governmental area; usually bigger than a locality, almost always smaller than a region <code>macrocounty</code> a related group of counties. Mostly in Europe. <code>region</code> states and provinces <code>macroregion</code> a related group of regions. Mostly in Europe <code>country</code> places that issue passports, nations, nation-states <code>coarse</code> alias for simultaneously using all administrative layers (everything except <code>venue</code> and <code>address</code>) <code>postalcode</code> postal code used by mail services <p>/v1/search?text=YMCA&amp;layers=venue,address</p> parameter value <code>text</code> YMCA <code>layers</code> venue,address"},{"location":"documentation/search/#available-search-parameters","title":"Available search parameters","text":"Parameter Type Required Default Example <code>text</code> string yes none <code>Union Square</code> <code>focus.point.lat</code> floating point number no none <code>48.581755</code> <code>focus.point.lon</code> floating point number no none <code>7.745843</code> <code>boundary.rect.min_lon</code> floating point number no none <code>139.2794</code> <code>boundary.rect.max_lon</code> floating point number no none <code>140.1471</code> <code>boundary.rect.min_lat</code> floating point number no none <code>35.53308</code> <code>boundary.rect.max_lat</code> floating point number no none <code>35.81346</code> <code>boundary.circle.lat</code> floating point number no none <code>43.818156</code> <code>boundary.circle.lon</code> floating point number no none <code>-79.186484</code> <code>boundary.circle.radius</code> floating point number no 50 <code>35</code> <code>boundary.gid</code> Pelias <code>gid</code> no none <code>whosonfirst:locality:101748355</code> <code>sources</code> string no all sources: osm,oa,gn,wof openstreetmap,wof <code>layers</code> string no all layers: address,venue,neighbourhood,locality,borough,localadmin,county,macrocounty,region,macroregion,country,coarse,postalcode address,venue <code>boundary.country</code> string no none <code>GBR,FRA</code> <code>size</code> integer no 10 20"},{"location":"documentation/services/","title":"Pelias services","text":"<p>A running Pelias installation is composed of several different services. Each service is well suited to a particular task.</p>"},{"location":"documentation/services/#service-use-cases","title":"Service Use Cases","text":"<p>Here's a list of which services provide which features in Pelias. If you don't need everything Pelias does, you may be able to get by without installing and running all the Pelias services</p> Service /v1/search /v1/autocomplete /v1/reverse /v1/reverse (coarse) Changing the display language of results (any endpoint) API required required required required required Placeholder required required Libpostal required PIP recommended required Interpolation optional"},{"location":"documentation/services/#descriptions","title":"Descriptions","text":""},{"location":"documentation/services/#api","title":"API","text":"<p>This is the core of Pelias. It talks to all other services (if available), Elasticsearch, and provides the interface for all queries to Pelias.</p>"},{"location":"documentation/services/#placeholder","title":"Placeholder","text":"<p>Placeholder is used specifically to handle the relational component of geocoding. Placeholder understands, for example, that Paris is a city in a country called France, but that there is another city called Paris in the state of Texas, USA.</p> <p>Placeholder also stores the translations of administrative areas in multiple languages. Therefore it is required if any support for multiple languages is desired.</p> <p>Currently, Placeholder is used only for forward geocoding on the <code>/v1/search</code> endpoint. In the future, it will also be used for autocomplete.</p>"},{"location":"documentation/services/#libpostal","title":"Libpostal","text":"<p>Libpostal is a library that provides an address parser using a statistical natural language processing model trained on OpenStreetMap, OpenAddresses, and other open data. It is quite good at parsing fully specified input, but cannot handle autocomplete very well.</p> <p>The data required for Libpostal to run is around 3GB, and has to be loaded into memory, so this service is fairly expensive to run, even for small installations.</p> <p>Unlike the other Pelias services, we didn't actually write a Pelias Libpostal service.  We recommend using the go-whosonfirst-libpostal service created by the Who's on First team.</p> <p>For convenience, we've packaged the go-whosonfirst-libpostal service using Docker in a way that fits in well with the rest of the Pelias Docker packages.</p>"},{"location":"documentation/services/#point-in-polygon-pip","title":"Point-in-Polygon (PIP)","text":"<p>The PIP service loads polygon data representing the boundaries of cities, states, regions, countries etc into memory, and can perform calculations on that geometric data. Its used to determine if a given point lies in a particular polygon. Thus, it's highly recommended for reverse geocoding.</p>"},{"location":"documentation/services/#interpolation","title":"Interpolation","text":"<p>The interpolation service combines street geometries with known addresses and address ranges, to allow estimating the position of addresses that might exist, but aren't in existing open data sources. It is only used by the <code>/v1/search</code> endpoint, but autocomplete support may be added in the future.</p>"},{"location":"documentation/structured-geocoding/","title":"Structured geocoding","text":"<p>Note: The structured endpoint is in beta. You may experience issues as the structured endpoint has not been as thoroughly tested as the <code>search</code> endpoint.</p> <p>With structured geocoding, you can search for the individual parts of a location. Structured geocoding is an option on the <code>search</code> endpoint, where a query takes the form of <code>/v1/search/structured</code>.</p> <p>For example, you want to find <code>30 West 26th Street, New York, NY</code>. With the geocoding parameter for <code>search</code>, you can only enter the entire location as one string, such as <code>text=30 West 26th Street, New York, NY</code>. However, with <code>search/structured</code>, you can specify that this location is composed of a street address, a locality, and a region.</p> <pre><code>{\n  address: '30 West 26th Street',\n  locality: 'New York',\n  region: 'NY'\n}\n</code></pre> <p>Structured geocoding can improve how the items in your query are parsed and interpreted in a search. An address such as <code>10 Park Place North Charleston South Carolina</code> could be viewed as a city name containing a directional (North Charleston in South Carolina), or as a street with a post-directional (10 Park Place North). By separating the components of the search input, you are reducing ambiguity in your query. This is also helpful because addresses and postal codes around the world are often formatted and ordered differently.</p> <p>One common use for structured geocoding is for geocoding a list or table of addresses, where each column represents a different portion of a location.</p> address city state country 1600 Pennsylvania Ave Washington DC US 10 Downing Street London GB 55 Rue du Faubourg Saint-Honor\u00e9 Paris FR Bulevardul Geniului 1 Bucharest Romania <p>With a regular <code>search</code> query, you would need to concatenate these columns into one string, but <code>search/structured</code> allows you to define a query that maintains the individual fields for address, city, state, and country.</p>"},{"location":"documentation/structured-geocoding/#structured-geocoding-parameters","title":"Structured geocoding parameters","text":"<p>You can use structured geocoding to search for the following parameters:</p> <ul> <li>address</li> <li>neighbourhood</li> <li>borough</li> <li>locality</li> <li>county</li> <li>region</li> <li>postalcode</li> <li>country</li> </ul> <p>Note that the other <code>search</code> parameters can also be combined with these, allowing you to filter and prioritize your results.</p>"},{"location":"documentation/structured-geocoding/#address","title":"address","text":"<p>The <code>address</code> parameter can contain a full address with house number or only a street name.</p> <p>Examples</p> <ul> <li>201 Spear Street</li> <li>Rue de Rivoli</li> <li>P\u0159\u00edluck\u00e1 1</li> </ul>"},{"location":"documentation/structured-geocoding/#neighbourhood","title":"neighbourhood","text":"<p>Neighbourhoods are vernacular geographic entities that may not necessarily be official administrative divisions but are important nonetheless.</p> <p>Examples</p> <ul> <li>Notting Hill in London</li> <li>Flatiron District in Manhattan</li> <li>Le Marais in Paris</li> </ul>"},{"location":"documentation/structured-geocoding/#borough","title":"borough","text":"<p>Boroughs are mostly known in the context of New York City, even though they may exist in other cities, such as Mexico City.</p> <p>Examples</p> <ul> <li>Manhattan</li> <li>Iztapalapa</li> </ul> <p>A structured geocoding request for <code>/v1/search/structured?locality=Manhattan&amp;region=NY</code>, returns boroughs along with localities.</p>"},{"location":"documentation/structured-geocoding/#locality","title":"locality","text":"<p>Localities are equivalent to what are commonly referred to as cities.</p> <p>Examples</p> <ul> <li>Bangkok</li> <li>Caracas</li> <li>Truth or Consequences in New Mexico</li> </ul>"},{"location":"documentation/structured-geocoding/#county","title":"county","text":"<p>Counties are administrative divisions between localities and regions.</p> <p>Examples</p> <ul> <li>Bucks in Pennsylvania</li> <li>Maui</li> <li>Alb-Donau-Kreis in Germany</li> </ul> <p>Counties are not as commonly used in geocoding as localities, but can be useful when attempting to disambiguate between localities. For instance, there are three cities named Red Lion in Pennsylvania but only one in each of three counties. Specifying a county disambiguates this list to a single result.</p>"},{"location":"documentation/structured-geocoding/#region","title":"region","text":"<p>Regions are normally the first-level administrative divisions within countries, analogous to states and provinces in the United States and Canada, respectively, though most other countries contain regions as well.</p> <p>Examples</p> <ul> <li>Delaware</li> <li>Ontario</li> <li>Ardennes</li> </ul> <p>Regions in the United States have common abbreviations, such as PA for Pennsylvania and NM for New Mexico.  The <code>region</code> parameter can be a full name or abbreviation, so specifying <code>/v1/search/structured?region=NM</code> is functionality equivalent to <code>/v1/search/structured?region=New Mexico</code>.</p>"},{"location":"documentation/structured-geocoding/#postalcode","title":"postalcode","text":"<p>Postal codes are used to aid in sorting mail with the format dictated by an administrative division, which is almost always countries.  Among other reasons, postal codes are unique within a country so they are useful in geocoding as a shorthand for a fairly granular geographical location.</p> <p>Examples</p> <ul> <li>90210</li> <li>CV23 9SL</li> <li>5439171</li> </ul> <p>Keep in mind that you can search for <code>postalcode</code> exclusively. So requests like /v1/search/structured?postalcode=87801 will return matching postalcode records.</p>"},{"location":"documentation/structured-geocoding/#country","title":"country","text":"<p>Countries are the highest-level administrative divisions supported in a search. In addition to full names, countries have common two- and three-letter abbreviations that are also supported values for the <code>country</code> parameter.</p> <p>Examples</p> <ul> <li>Liechtenstein</li> <li>CMR (Cameroon)</li> <li>Bermuda</li> </ul>"},{"location":"documentation/structured-geocoding/#whos-on-first-layer-mappings-reference","title":"Who's On First layer mappings reference","text":"<p>The Who's on First gazetteer is one of the datasets used as a source of search data. Use this table is a reference between the parameters for structured geocoding and the types of places in Who's on First.</p> Structured geocoding parameter Who's on First placetype <code>neighbourhood</code> neighbourhood <code>borough</code> borough <code>locality</code> locality, localadmin (and borough if <code>borough</code> parameter is not supplied) <code>county</code> county, macrocounty <code>region</code> region, macroregion <code>country</code> dependency, country <p>For example, Peach Bottom, Pennsylvania is only a <code>localadmin</code> place type and not a <code>locality</code> in Who's on First. For simplicity, if a structured geocoding request specifies <code>locality=Peach Bottom&amp;region=Pennsylvania</code>, then <code>Peach Bottom</code> in both the <code>locality</code> and <code>localadmin</code> layers are searched.</p>"},{"location":"documentation/use-cors/","title":"Load data from the browser","text":"<p>For security reasons, web browsers prevent what are called cross-origin or cross-site requests from one domain to another. JavaScript <code>XMLHTTPRequests</code> (commonly called \u201cAJAX\u201d requests) inherit all the authentication context of the logged in user, so a malicious web page could try to make malicious requests that cross domain contexts and cause trouble. Historically, that has made it difficult for web developers to build web applications making use of third-party APIs.</p> <p>Fortunately, techniques have since been developed that allow developers to securely access APIs cross-domain.</p>"},{"location":"documentation/use-cors/#cross-origin-resource-sharing-cors","title":"Cross-Origin Resource Sharing (CORS)","text":"<p><code>CORS</code> is the recommended standard for allowing your web browser and a web server to negotiate and allow requests to be made across domain contexts. <code>CORS</code> is supported in modern Chrome, Firefox, Safari, and Internet Explorer (10+) web browsers. It became a W3C Recommendation in 2014.</p> <p>You don\u2019t need to do anything special to use <code>CORS</code> with JavaScript in a modern browser. Your web browser and the Pelias servers will automatically negotiate the cross-origin request. For example, to make a <code>CORS</code> request with <code>jQuery</code>, you\u2019d make your request like you were performing it within the context of your own domain.</p> <p>For a full list of supported browsers see: http://caniuse.com/#feat=cors</p>"},{"location":"documentation/use-cors/#add-a-search-box-to-a-leaflet-map","title":"Add a search box to a Leaflet map","text":"<p>You can add a Pelias box to any Leaflet map.</p> <p>See the Mapzen.js documentation for instructions. There is also a tutorial available.</p>"},{"location":"documentation/use-cors/#loading-data-with-jquery","title":"Loading data with jQuery","text":"<pre><code>$.ajax({\nurl: \"https://search.mapzen.com/v1/search\",\nmethod: \"GET\",\ndataType: \"json\",\ndata: {\n\"text\": \"London, UK\",\n\"api_key\": \"your-mapzen-api-key\"\n},\nsuccess: function( data, status, jqxhr ){\nconsole.log( \"Request received:\", data );\n},\nerror: function( jqxhr, status, error ){\nconsole.log( \"Something went wrong!\" );\n}\n});\n</code></pre> <p>interactive demo: http://jsfiddle.net/missinglink/fb6p0par/</p>"},{"location":"documentation/use-cors/#loading-data-with-angular","title":"Loading data with Angular","text":"<pre><code>$http({\nurl: \"https://search.mapzen.com/v1/search\",\nmethod: \"GET\",\nheaders: { \"Accept\": \"application/json\" },\nparams: {\n\"text\": \"London, UK\",\n\"api_key\": \"your-mapzen-api-key\"\n},\n})\n.success(function( data, status ) {\nconsole.log( \"Request received:\", data );\n})\n.error(function( data, status ) {\nconsole.log( \"Something went wrong!\" );\n});\n</code></pre> <p>interactive demo: http://jsfiddle.net/missinglink/nchh8a9j/</p>"},{"location":"documentation/use-cors/#why-not-jsonp","title":"Why not JSONP?","text":"<p>Also called \u201cJSON with Padding\u201d, <code>JSONP</code> is a technique for fooling a web browser into performing cross-origin requests using a special <code>&lt;script&gt;</code> tag that uses the <code>src</code> attribute that to make a special API request.</p> <p>Instead of responding with a <code>JSON</code> object, the server responds with JavaScript code that calls a client-declared callback function, passing the data as that function\u2019s first parameter.</p> <p><code>JSONP</code> is disabled by default for Pelias, as <code>CORS</code> is offered as a more modern alternative.</p> <p>You can find more information online by performing a web search for <code>\"CORS vs JSONP\"</code> and <code>\"Security risks with JSONP\"</code>.</p> <p>If you are having any issues implementing <code>CORS</code> with Pelias, open an issue in the main Pelias GitHub repository. Please include the name of any frameworks you are using and some example code.</p> <p>This content is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Some content adapted from the Socrata Documentation.</p>"}]}